{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to Excaligen \ud83c\udfa8","text":"<p>Excaligen is a lightweight, zero-dependency Python library that lets you programmatically generate Excalidraw files. </p> <p>If you've ever wanted to automate your diagrams creation, map out your cloud architecture, or generate mind maps directly from your Python code, you are in the right place!</p>"},{"location":"#quick-glance","title":"\ud83d\ude80 Quick Glance","text":"<p>Excaligen uses a simple, fluent API (the builder pattern). You don't need to worry about complex JSON schemas\u2014just tell the canvas what you want, and chain your styling methods together.</p> <pre><code>from excaligen.SceneBuilder import SceneBuilder\n\n# 1. Grab a fresh canvas\nscene = SceneBuilder()\n\n# 2. Drop some shapes onto the scene\ncentral_topic = scene.ellipse('Central topic').center(0, 0)\nsubtopic = scene.rectangle('Subtopic').center(350, 100)\n\n# 3. Bind them together with an arrow\nscene.arrow('points to').bind(central_topic, subtopic)\n\n# 4. Save your masterpiece!\nscene.save('my_diagram.excalidraw')\n</code></pre> <p>(You can then drag and drop my_diagram.excalidraw directly into excalidraw.com!) </p>"},{"location":"#where-to-go-next","title":"\ud83d\udcda Where to go next?","text":"<p>Ready to dive in? Choose your path:</p>"},{"location":"#the-developer-guide","title":"\ud83d\udcd6 The Developer Guide","text":"<p>New to Excaligen? Start here. We will walk you through creating your first scene, styling elements, grouping objects, and embedding images.</p> <p>The Developer Guide</p>"},{"location":"#api-reference","title":"\u2699\ufe0f API Reference","text":"<p>Already know the basics? Jump into the API docs to see every method, shape, and parameter available to you.</p> <p>API Reference</p>"},{"location":"#github-repository","title":"\ud83d\udc19 GitHub Repository","text":"<p>Want to see the source code, report a bug, or contribute? Head over to our GitHub.</p> <p>GitHub Repository</p>"},{"location":"api/","title":"\ud83c\udfa8 Excaligen API Documentation","text":"<p>This is the API documentation for the Excaligen library</p> <p>\u2728 The following classes are available:</p>"},{"location":"api/#scenebuilder","title":"SceneBuilder","text":"<ul> <li>SceneBuilder     The SceneBuilder class provides methods to add various diagram elements</li> </ul>"},{"location":"api/#defaults","title":"Defaults","text":"<ul> <li>Defaults     A class to hold default values for various element properties</li> </ul>"},{"location":"api/#color","title":"Color","text":"<ul> <li>Color     Color class for handling RGB and HSL colors</li> </ul>"},{"location":"api/#arrow","title":"Arrow","text":"<ul> <li>Arrow     A class representing an arrow element in Excalidraw with various connection styles</li> </ul>"},{"location":"api/#diamond","title":"Diamond","text":"<ul> <li>Diamond     A class representing a diamond shape in the diagram</li> </ul>"},{"location":"api/#ellipse","title":"Ellipse","text":"<ul> <li>Ellipse     A class representing an elliptical shape element</li> </ul>"},{"location":"api/#frame","title":"Frame","text":"<ul> <li>Frame     A visual container that can hold other elements and automatically adjusts its size</li> </ul>"},{"location":"api/#group","title":"Group","text":"<ul> <li>Group     A container class that represents a group of elements</li> </ul>"},{"location":"api/#image","title":"Image","text":"<ul> <li>Image     A class representing an image element that can be loaded from various sources</li> </ul>"},{"location":"api/#line","title":"Line","text":"<ul> <li>Line     A line element that draws a straight or curved line segments between the given points</li> </ul>"},{"location":"api/#rectangle","title":"Rectangle","text":"<ul> <li>Rectangle     A class representing a rectangular shape in a 2D space</li> </ul>"},{"location":"api/#text","title":"Text","text":"<ul> <li>Text     A class representing text elements in excaligen</li> </ul>"},{"location":"api/arrow/","title":"Class Arrow","text":"<p>A class representing an arrow element in Excalidraw with various connection styles. It creates arrow elements that can connect different elements in various ways including straight lines, curves, arcs and elbowed connections. It supports customizable arrowheads, gaps between connected elements, and different binding behaviors. The arrow can be styled with: - Different connection types (straight, arc, curve, elbow) - Customizable start and end arrowheads - Adjustable gaps between connected elements - Binding capabilities to connect elements - Various arrow directions and angles</p> <p>[!WARNING] Do not instantiate this class directly. Use <code>SceneBuilder.arrow()</code> instead.</p>"},{"location":"api/arrow/#methods","title":"Methods","text":""},{"location":"api/arrow/#init","title":"init","text":"<p><pre><code>    def __init__(self, defaults: Defaults, listener: AbstractPlainLabelListener, label: str | Text | None = None) -&gt; None:\n</code></pre> Initialize self.  See help(type(self)) for accurate signature.</p>"},{"location":"api/arrow/#append","title":"append","text":"<p><pre><code>    def append(self, points: list[Point]) -&gt; Self:\n</code></pre> Appends points to the line.</p>"},{"location":"api/arrow/#arguments","title":"Arguments","text":"Name Type Description <code>points</code> <code>list[Point]</code> A list of Point objects to append. Returns: Self: The instance of the class with updated points, width, and height."},{"location":"api/arrow/#arc","title":"arc","text":"<p><pre><code>    def arc(self, radius: float) -&gt; Self:\n</code></pre> Approximate an arc between the bound elements with the given radius. The center of the arc is determined by the radius and the positions of the bound elements by assuming the center of the start element and the center of the end element are oriented clockwise.</p>"},{"location":"api/arrow/#arguments_1","title":"Arguments","text":"Name Type Description <code>radius</code> <code>float</code> The radius of the arc."},{"location":"api/arrow/#returns","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the Arrow class.</p>"},{"location":"api/arrow/#arrowheads","title":"arrowheads","text":"<p><pre><code>    def arrowheads(self, start: str | None = None, end: str | None = 'arrow') -&gt; Self:\n</code></pre> Set the arrowhead styles for the start and end of the arrow. Valid arrowheads values are None, 'arrow', 'bar', 'dot' and 'triangle'.</p>"},{"location":"api/arrow/#arguments_2","title":"Arguments","text":"Name Type Description <code>start</code> <code>str, optional</code> The style of the start arrowhead. Defaults to None. <code>end</code> <code>str, optional</code> The style of the end arrowhead. Defaults to 'arrow'."},{"location":"api/arrow/#returns_1","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the Arrow class.</p>"},{"location":"api/arrow/#raises","title":"Raises","text":"<p>ValueError: If an invalid arrowhead style is provided.</p>"},{"location":"api/arrow/#bind","title":"bind","text":"<p><pre><code>    def bind(self, start: AbstractElement, end: AbstractElement) -&gt; Self:\n</code></pre> Bind the arrow between two elements, supporting different connection styles.</p>"},{"location":"api/arrow/#arguments_3","title":"Arguments","text":"Name Type Description <code>start</code> <code>AbstractElement</code> The start element. <code>end</code> <code>AbstractElement</code> The end element."},{"location":"api/arrow/#returns_2","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the Arrow class.</p>"},{"location":"api/arrow/#center","title":"center","text":"<p><pre><code>    def center(self, *args) -&gt; Self | tuple[float, float]:\n</code></pre> Get or set the center coordinates of the element.</p>"},{"location":"api/arrow/#arguments_4","title":"Arguments","text":"Name Type Description <code>*args</code> <code>None</code> Supports two signatures: 1. center() -&gt; tuple[float, float] Returns the (x, y) coordinates of the center. 2. center(x, y) -&gt; Self Sets the center to (x, y) and returns self for chaining."},{"location":"api/arrow/#returns_3","title":"Returns","text":"<p>Type: <code>tuple[float, float]  or  Self</code></p> <p>Depending on the arguments.</p>"},{"location":"api/arrow/#color","title":"color","text":"<p><pre><code>    def color(self, color: str | Color) -&gt; Self:\n</code></pre> Set the stroke (outline) color as #RRGGBB, color name or Color object.</p>"},{"location":"api/arrow/#arguments_5","title":"Arguments","text":"Name Type Description <code>color</code> <code>str  or  Color</code> The color to set, specified as a hex string $RRGGBB, color name, or Color object."},{"location":"api/arrow/#returns_4","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the AbstractStrokedElement class.</p>"},{"location":"api/arrow/#curve","title":"curve","text":"<p><pre><code>    def curve(self, start_angle: float | str, end_angle: float | str) -&gt; Self:\n</code></pre> Generate a curve between the bound elements using the given start and end tangent angles.</p>"},{"location":"api/arrow/#arguments_6","title":"Arguments","text":"Name Type Description <code>start_angle</code> <code>float  or  str</code> The start tangent angle. It's either float value in radians or one of the strings 'L', 'R', 'U', 'D', representing left, right, up, or down respectively. <code>end_angle</code> <code>float  or  str</code> The end tangent angle. It's either float value in radians or one of the strings 'L', 'R', 'U', 'D', representing left, right, up, or down respectively."},{"location":"api/arrow/#returns_5","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the Arrow class.</p>"},{"location":"api/arrow/#elbow","title":"elbow","text":"<p><pre><code>    def elbow(self, start_direction: str, end_direction: str) -&gt; Self:\n</code></pre> Set the arrow to have an elbow (right-angle turn).</p>"},{"location":"api/arrow/#arguments_7","title":"Arguments","text":"Name Type Description <code>start_direction</code> <code>str</code> The direction of the start elbow. It's one of the strings 'L', 'R', 'U', 'D', representing left, right, up, or down respectively. <code>end_direction</code> <code>str</code> The direction of the end elbow. It's one of the strings 'L', 'R', 'U', 'D', representing left, right, up, or down respectively."},{"location":"api/arrow/#returns_6","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the Arrow class.</p>"},{"location":"api/arrow/#gap","title":"gap","text":"<p><pre><code>    def gap(self, gap: float, end_gap: float | None = None) -&gt; Self:\n</code></pre> Set the gap at the start and end of the arrow.</p>"},{"location":"api/arrow/#arguments_8","title":"Arguments","text":"Name Type Description <code>gap</code> <code>float</code> The gap at the start of the arrow. <code>end_gap</code> <code>float, optional</code> The gap at the end of the arrow. Defaults to the value of <code>gap</code>."},{"location":"api/arrow/#returns_7","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the Arrow class.</p>"},{"location":"api/arrow/#label","title":"label","text":"<p><pre><code>    def label(self, text: Text | str) -&gt; Self:\n</code></pre> Set the label text for the element.</p>"},{"location":"api/arrow/#arguments_9","title":"Arguments","text":"Name Type Description <code>text</code> <code>Text  or  str</code> The text element to set as the label or plain text."},{"location":"api/arrow/#returns_8","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the class.</p>"},{"location":"api/arrow/#link","title":"link","text":"<p><pre><code>    def link(self, target: \"str | AbstractElement\") -&gt; Self:\n</code></pre> Establishes a link to the given target, which can be either a string URL or an AbstractElement instance.</p>"},{"location":"api/arrow/#arguments_10","title":"Arguments","text":"Name Type Description <code>target</code> <code>str  or  AbstractElement</code> The target to link to. If it's an AbstractElement, a URL will be generated using its ID. If it's a string, it will be used directly as the link."},{"location":"api/arrow/#returns_9","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the current object with the updated link.</p>"},{"location":"api/arrow/#raises_1","title":"Raises","text":"<p>ValueError: If the target is neither a string nor an AbstractElement.</p>"},{"location":"api/arrow/#opacity","title":"opacity","text":"<p><pre><code>    def opacity(self, opacity: int) -&gt; Self:\n</code></pre> Set the opacity of the element.</p>"},{"location":"api/arrow/#arguments_11","title":"Arguments","text":"Name Type Description <code>opacity</code> <code>int</code> The opacity value to set, must be in the range 0-100. 100 is fully opaque, 0 is fully transparent."},{"location":"api/arrow/#returns_10","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the element with updated opacity.</p>"},{"location":"api/arrow/#raises_2","title":"Raises","text":"<p>ValueError: If the opacity value is not within the range 0-100.</p>"},{"location":"api/arrow/#orbit","title":"orbit","text":"<p><pre><code>    def orbit(self, *args) -&gt; Self:\n</code></pre> Positions the element relative to a reference using polar coordinates. This method allows placing the element such that its center will be at (radius, angle) from a reference. The reference can be either another AbstractElement or a point (x, y).</p>"},{"location":"api/arrow/#arguments_12","title":"Arguments","text":"Name Type Description <code>*args</code> <code>None</code> Supports two signatures: 1. orbit(element, radius, angle) <code>element</code> <code>AbstractElement</code> The reference element to orbit around. <code>radius</code> <code>float</code> The distance from the center of the reference. <code>angle</code> <code>float</code> The angle to position the element at, in radians."},{"location":"api/arrow/#returns_11","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the element.</p>"},{"location":"api/arrow/#raises_3","title":"Raises","text":"<p>ValueError: If the arguments do not match the expected signatures.</p>"},{"location":"api/arrow/#points","title":"points","text":"<p><pre><code>    def points(self, points: list[Point]) -&gt; Self:\n</code></pre> Set the points of the arrow.</p>"},{"location":"api/arrow/#arguments_13","title":"Arguments","text":"Name Type Description <code>points</code> <code>list[Point]</code> The points of the arrow."},{"location":"api/arrow/#returns_12","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the Arrow class.</p>"},{"location":"api/arrow/#position","title":"position","text":"<p><pre><code>    def position(self, x: float, y: float) -&gt; Self:\n</code></pre> Sets the position of the element.</p>"},{"location":"api/arrow/#arguments_14","title":"Arguments","text":"Name Type Description <code>x</code> <code>float</code> The x-coordinate of the element. <code>y</code> <code>float</code> The y-coordinate of the element."},{"location":"api/arrow/#returns_13","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the element with updated position.</p>"},{"location":"api/arrow/#prepend","title":"prepend","text":"<p><pre><code>    def prepend(self, points: list[Point]) -&gt; Self:\n</code></pre> Prepends points to the line.</p>"},{"location":"api/arrow/#arguments_15","title":"Arguments","text":"Name Type Description <code>points</code> <code>list[Point]</code> A list of Point objects to prepend. Returns: Self: The instance of the class with updated points, width, and height."},{"location":"api/arrow/#rotate","title":"rotate","text":"<p><pre><code>    def rotate(self, angle: float) -&gt; Self:\n</code></pre> Rotate the element clockwise by a specified angle.</p>"},{"location":"api/arrow/#arguments_16","title":"Arguments","text":"Name Type Description <code>angle</code> <code>float</code> The angle to rotate the element clockwise by, in radians."},{"location":"api/arrow/#returns_14","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the element after rotation.</p>"},{"location":"api/arrow/#roundness","title":"roundness","text":"<p><pre><code>    def roundness(self, roundness: str) -&gt; Self:\n</code></pre> Set the roundness style of the shape.</p>"},{"location":"api/arrow/#arguments_17","title":"Arguments","text":"Name Type Description <code>roundness</code> <code>str</code> The roundness style to set. Acceptable values are: - \"sharp\": Sets the shape to have sharp corners. - \"round\": Sets the shape to have rounded corners."},{"location":"api/arrow/#returns_15","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the shape with the updated roundness style.</p>"},{"location":"api/arrow/#raises_4","title":"Raises","text":"<p>ValueError: If the provided roundness style is not \"sharp\" or \"round\".</p>"},{"location":"api/arrow/#size","title":"size","text":"<p><pre><code>    def size(self, *args) -&gt; Self | tuple[float, float]:\n</code></pre> Get or set the size of the element.</p>"},{"location":"api/arrow/#arguments_18","title":"Arguments","text":"Name Type Description <code>*args</code> <code>None</code> Supports two signatures: 1. size() -&gt; tuple[float, float] Returns the (width, height) of the element. 2. size(width, height) -&gt; Self Sets the size to (width, height) and returns self for chaining."},{"location":"api/arrow/#returns_16","title":"Returns","text":"<p>Type: <code>tuple[float, float]  or  Self</code></p> <p>Depending on the arguments.</p>"},{"location":"api/arrow/#sloppiness","title":"sloppiness","text":"<p><pre><code>    def sloppiness(self, value: int | str) -&gt; Self:\n</code></pre> Set the stroke sloppiness by int (0, 1, 2) or by string ('architect', 'artist', 'cartoonist').</p>"},{"location":"api/arrow/#arguments_19","title":"Arguments","text":"Name Type Description <code>value</code> <code>int  or  str</code> The sloppiness value to set, specified as an integer (0, 1, 2) or a string ('architect', 'artist', 'cartoonist')."},{"location":"api/arrow/#returns_17","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the AbstractStrokedElement class.</p>"},{"location":"api/arrow/#raises_5","title":"Raises","text":"<p>ValueError: If an invalid sloppiness value is provided.</p>"},{"location":"api/arrow/#stroke","title":"stroke","text":"<p><pre><code>    def stroke(self, style: str) -&gt; Self:\n</code></pre> Set the stroke style (solid, dotted, dashed).</p>"},{"location":"api/arrow/#arguments_20","title":"Arguments","text":"Name Type Description <code>style</code> <code>str</code> The stroke style to set, specified as 'solid', 'dotted', or 'dashed'."},{"location":"api/arrow/#returns_18","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the AbstractStrokedElement class.</p>"},{"location":"api/arrow/#raises_6","title":"Raises","text":"<p>ValueError: If an invalid stroke style is provided.</p>"},{"location":"api/arrow/#thickness","title":"thickness","text":"<p><pre><code>    def thickness(self, thickness: int | str) -&gt; Self:\n</code></pre> Set the stroke thickness by int (1, 2, 3) or by string ('thin', 'bold', 'extra-bold').</p>"},{"location":"api/arrow/#arguments_21","title":"Arguments","text":"Name Type Description <code>thickness</code> <code>int  or  str</code> The thickness to set, specified as an integer (1, 2, 3) or a string ('thin', 'bold', 'extra-bold')."},{"location":"api/arrow/#returns_19","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the AbstractStrokedElement class.</p>"},{"location":"api/arrow/#raises_7","title":"Raises","text":"<p>ValueError: If an invalid thickness value is provided.</p>"},{"location":"api/color/","title":"Class Color","text":"<p>Color class for handling RGB and HSL colors. Contains also a static method for parsing color strings. The following color names are supported (case insensitive): <pre><code>AliceBlue, AntiqueWhite, Aqua, Aquamarine, Azure, Beige,\nBisque, Black, BlanchedAlmond, Blue, BlueViolet, Brown, BurlyWood,\nCadetBlue, Chartreuse, Chocolate, Coral, CornflowerBlue, Cornsilk, Crimson, Cyan,\nDarkBlue, DarkCyan, DarkGoldenRod, DarkGray, DarkGrey, DarkGreen, DarkKhaki, DarkMagenta, DarkOliveGreen, DarkOrange, DarkOrchid, DarkRed, DarkSalmon, DarkSeaGreen, DarkSlateBlue, DarkSlateGray, DarkSlateGrey, DarkTurquoise, DarkViolet, DeepPink, DeepSkyBlue, DimGray, DimGrey, DodgerBlue,\nFireBrick, FloralWhite, ForestGreen, Fuchsia,\nGainsboro, GhostWhite, Gold, GoldenRod, Gray, Grey, Green, GreenYellow,\nHoneyDew, HotPink,\nIndianRed, Indigo, Ivory,\nKhaki,\nLavender, LavenderBlush, LawnGreen, LemonChiffon, LightBlue, LightCoral, LightCyan, LightGoldenRodYellow, LightGray, LightGrey, LightGreen, LightPink, LightSalmon, LightSeaGreen, LightSkyBlue, LightSlateGray, LightSlateGrey, LightSteelBlue, LightYellow, Lime, LimeGreen, Linen,\nMagenta, Maroon, MediumAquaMarine, MediumBlue, MediumOrchid, MediumPurple, MediumSeaGreen, MediumSlateBlue, MediumSpringGreen, MediumTurquoise, MediumVioletRed, MidnightBlue, MintCream, MistyRose, Moccasin,\nNavajoWhite, Navy,\nOldLace, Olive, OliveDrab, Orange, OrangeRed, Orchid,\nPaleGoldenRod, PaleGreen, PaleTurquoise, PaleVioletRed, PapayaWhip, PeachPuff, Peru, Pink, Plum, PowderBlue, Purple,\nRebeccaPurple, Red, RosyBrown, RoyalBlue,\nSaddleBrown, Salmon, SandyBrown, SeaGreen, SeaShell, Sienna, Silver, SkyBlue, SlateBlue, SlateGray, SlateGrey, Snow, SpringGreen, SteelBlue,\nTan, Teal, Thistle, Tomato, Transparent, Turquoise,\nViolet,\nWheat, White, WhiteSmoke,\nYellow, YellowGreen\n</code></pre></p>"},{"location":"api/color/#methods","title":"Methods","text":""},{"location":"api/color/#init","title":"init","text":"<p><pre><code>    def __init__(self):\n</code></pre> Initialize self.  See help(type(self)) for accurate signature.</p>"},{"location":"api/color/#darken","title":"darken","text":"<p><pre><code>    def darken(self, percent: int) -&gt; \"Self\":\n</code></pre> Darkens the color by a given percentage. percent should be an integer between 0 and 100. Calculation is absolute: new_lightness = current_lightness - percent</p>"},{"location":"api/color/#from_","title":"from_","text":"<p><pre><code>    def from_(input_color: \"str | Color\") -&gt; str:\n</code></pre> Converts input color to string representation. Accepts either a Color instance or a string.</p>"},{"location":"api/color/#hsl","title":"hsl","text":"<p><pre><code>    def hsl(self, *args) -&gt; \"Self | tuple[int, int, int]\":\n</code></pre> Sets the color using HSL values, or returns the current HSL values if no arguments are provided.</p>"},{"location":"api/color/#hsl_to_rgb","title":"hsl_to_rgb","text":"<p><pre><code>    def hsl_to_rgb(h: int, s: int, l: int) -&gt; tuple[int, int, int]:\n</code></pre> Converts HSL values to RGB.</p>"},{"location":"api/color/#lighten","title":"lighten","text":"<p><pre><code>    def lighten(self, percent: int) -&gt; \"Self\":\n</code></pre> Lightens the color by a given percentage. percent should be an integer between 0 and 100. Calculation is absolute: new_lightness = current_lightness + percent</p>"},{"location":"api/color/#rgb","title":"rgb","text":"<p><pre><code>    def rgb(self, *args) -&gt; \"Self | tuple[int, int, int]\":\n</code></pre> Sets the color using RGB values, or returns the current RGB values if no arguments are provided.</p>"},{"location":"api/color/#rgb_to_hsl","title":"rgb_to_hsl","text":"<p><pre><code>    def rgb_to_hsl(r: int, g: int, b: int) -&gt; tuple[int, int, int]:\n</code></pre> Converts RGB values to HSL.</p>"},{"location":"api/defaults/","title":"Class Defaults","text":"<p>A class to hold default values for various element properties. This class provides a centralized way to manage default settings for elements/ The initial values are: <pre><code>size(130, 80)\nopacity(100)\nrotate(0)\nsloppiness('artist')\nroundness('round')\nstroke('solid')\nthickness(1)\ncolor('#000000')\nbackground('transparent')\nfill('hachure')\nfontsize(16)\nfont('Hand drawn')\nalign('center')\nbaseline('middle')\nautoresize(True)\nspacing(1.25)\narrowheads(None, 'arrow')\n</code></pre></p>"},{"location":"api/defaults/#methods","title":"Methods","text":""},{"location":"api/defaults/#init","title":"init","text":"<p><pre><code>    def __init__(self):\n</code></pre> Initialize self.  See help(type(self)) for accurate signature.</p>"},{"location":"api/defaults/#align","title":"align","text":"<p><pre><code>    def align(self, align: str) -&gt; Self:\n</code></pre> Set the horizontal text alignment (left, center, right).</p>"},{"location":"api/defaults/#arguments","title":"Arguments","text":"Name Type Description <code>align</code> <code>str</code> The horizontal alignment to set."},{"location":"api/defaults/#returns","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the Text class.</p>"},{"location":"api/defaults/#raises","title":"Raises","text":"<p>ValueError: If an invalid alignment is provided.</p>"},{"location":"api/defaults/#arrowheads","title":"arrowheads","text":"<p><pre><code>    def arrowheads(self, start: str | None, end: str | None) -&gt; Self:\n</code></pre> Set the arrowhead styles for the start and end of the arrow. Valid arrowheads values are None, 'arrow', 'bar', 'dot' and 'triangle'.</p>"},{"location":"api/defaults/#arguments_1","title":"Arguments","text":"Name Type Description <code>start</code> <code>str, optional</code> The style of the start arrowhead. <code>end</code> <code>str, optional</code> The style of the end arrowhead."},{"location":"api/defaults/#returns_1","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the Arrow class.</p>"},{"location":"api/defaults/#raises_1","title":"Raises","text":"<p>ValueError: If an invalid arrowhead style is provided.</p>"},{"location":"api/defaults/#autoresize","title":"autoresize","text":"<p><pre><code>    def autoresize(self, enabled: bool) -&gt; Self:\n</code></pre> Enable or disable automatic text box resizing.</p>"},{"location":"api/defaults/#arguments_2","title":"Arguments","text":"Name Type Description <code>enabled</code> <code>bool</code> Whether to enable automatic resizing."},{"location":"api/defaults/#returns_2","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the Text class.</p>"},{"location":"api/defaults/#background","title":"background","text":"<p><pre><code>    def background(self, color: str | Color) -&gt; Self:\n</code></pre> Sets the background color of the element.</p>"},{"location":"api/defaults/#arguments_3","title":"Arguments","text":"Name Type Description <code>color</code> <code>str  or  Color</code> The background color, specified as a hex string (#RRGGBB), a color name, or a Color object."},{"location":"api/defaults/#returns_3","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance defaults with updated background color.</p>"},{"location":"api/defaults/#baseline","title":"baseline","text":"<p><pre><code>    def baseline(self, align: str) -&gt; Self:\n</code></pre> Set the vertical text alignment (top, middle, bottom).</p>"},{"location":"api/defaults/#arguments_4","title":"Arguments","text":"Name Type Description <code>align</code> <code>str</code> The vertical alignment to set."},{"location":"api/defaults/#returns_4","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the Text class.</p>"},{"location":"api/defaults/#raises_2","title":"Raises","text":"<p>ValueError: If an invalid vertical alignment is provided.</p>"},{"location":"api/defaults/#color","title":"color","text":"<p><pre><code>    def color(self, color: str | Color) -&gt; Self:\n</code></pre> Set the stroke (outline) color as #RRGGBB, color name or Color object.</p>"},{"location":"api/defaults/#arguments_5","title":"Arguments","text":"Name Type Description <code>color</code> <code>str  or  Color</code> The color to set, specified as a hex string $RRGGBB, color name, or Color object."},{"location":"api/defaults/#returns_5","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the AbstractStrokedElement class.</p>"},{"location":"api/defaults/#fill","title":"fill","text":"<p><pre><code>    def fill(self, style: str) -&gt; Self:\n</code></pre> Sets the fill style of the element.</p>"},{"location":"api/defaults/#arguments_6","title":"Arguments","text":"Name Type Description <code>style</code> <code>str</code> The fill style to be applied. Must be one of 'hachure', 'cross-hatch', or 'solid'."},{"location":"api/defaults/#returns_6","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance defaults with updated fill style.</p>"},{"location":"api/defaults/#font","title":"font","text":"<p><pre><code>    def font(self, family: str) -&gt; Self:\n</code></pre> Sets the font family of the text element.</p>"},{"location":"api/defaults/#arguments_7","title":"Arguments","text":"Name Type Description <code>family</code> <code>str</code> The font family to set, specified as a string ('Excalifont', 'Comic Shaans', 'Lilita One', 'Nunito', 'Hand-drawn', 'Normal', 'Code')."},{"location":"api/defaults/#returns_7","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance defaults with updated font family.</p>"},{"location":"api/defaults/#fontsize","title":"fontsize","text":"<p><pre><code>    def fontsize(self, size: int | str) -&gt; Self:\n</code></pre> Sets the font size of the text element.</p>"},{"location":"api/defaults/#arguments_8","title":"Arguments","text":"Name Type Description <code>size</code> <code>int  or  str</code> The font size to set, specified as an integer (e.g., 12, 14, 16) or a string ('small', 'medium', 'large')."},{"location":"api/defaults/#returns_8","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance defaults with updated font size.</p>"},{"location":"api/defaults/#opacity","title":"opacity","text":"<p><pre><code>    def opacity(self, opacity: int) -&gt; Self:\n</code></pre> Sets the opacity of the element.</p>"},{"location":"api/defaults/#arguments_9","title":"Arguments","text":"Name Type Description <code>opacity</code> <code>int</code> The opacity of the element (0-100)."},{"location":"api/defaults/#returns_9","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance defaults with updated opacity.</p>"},{"location":"api/defaults/#raises_3","title":"Raises","text":"<p>ValueError: If the opacity value is not within the range 0-100.</p>"},{"location":"api/defaults/#rotate","title":"rotate","text":"<p><pre><code>    def rotate(self, angle: float) -&gt; Self:\n</code></pre> Sets the rotation angle of the element.</p>"},{"location":"api/defaults/#arguments_10","title":"Arguments","text":"Name Type Description <code>angle</code> <code>float</code> The rotation angle in radians."},{"location":"api/defaults/#returns_10","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance defaults with updated angle.</p>"},{"location":"api/defaults/#roundness","title":"roundness","text":"<p><pre><code>    def roundness(self, roundness: str) -&gt; Self:\n</code></pre> Sets the roundness style of the element.</p>"},{"location":"api/defaults/#arguments_11","title":"Arguments","text":"Name Type Description <code>roundness</code> <code>str</code> The roundness style to set. Acceptable values are: - \"sharp\": Sets the shape to have sharp corners. - \"round\": Sets the shape to have rounded corners. Returns: Self: The instance defaults with updated roundness style."},{"location":"api/defaults/#size","title":"size","text":"<p><pre><code>    def size(self, width: float, height: float) -&gt; Self:\n</code></pre> Sets the size of the element.</p>"},{"location":"api/defaults/#arguments_12","title":"Arguments","text":"Name Type Description <code>width</code> <code>float</code> The width of the element. <code>height</code> <code>float</code> The height of the element."},{"location":"api/defaults/#returns_11","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance defaults with updated size.</p>"},{"location":"api/defaults/#sloppiness","title":"sloppiness","text":"<p><pre><code>    def sloppiness(self, sloppiness: int | str) -&gt; Self:\n</code></pre> Sets the sloppiness of the element.</p>"},{"location":"api/defaults/#arguments_13","title":"Arguments","text":"Name Type Description <code>sloppiness</code> <code>int  or  str</code> The sloppiness value to set, specified as an integer (0, 1, 2) or a string ('architect', 'artist', 'cartoonist')."},{"location":"api/defaults/#returns_12","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance defaults with updated sloppiness.</p>"},{"location":"api/defaults/#spacing","title":"spacing","text":"<p><pre><code>    def spacing(self, height: float) -&gt; Self:\n</code></pre> Set the line height manually.</p>"},{"location":"api/defaults/#arguments_14","title":"Arguments","text":"Name Type Description <code>height</code> <code>float</code> The line height to set."},{"location":"api/defaults/#returns_13","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the Text class.</p>"},{"location":"api/defaults/#stroke","title":"stroke","text":"<p><pre><code>    def stroke(self, style: str) -&gt; Self:\n</code></pre> Sets the stroke style of the element.</p>"},{"location":"api/defaults/#arguments_15","title":"Arguments","text":"Name Type Description <code>stroke</code> <code>str</code> The stroke style to set, specified as a string ('solid', 'dashed', 'dotted')."},{"location":"api/defaults/#returns_14","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance defaults with updated stroke style.</p>"},{"location":"api/defaults/#thickness","title":"thickness","text":"<p><pre><code>    def thickness(self, thickness: int | str) -&gt; Self:\n</code></pre> Sets the stroke thickness of the element.</p>"},{"location":"api/defaults/#arguments_16","title":"Arguments","text":"Name Type Description <code>thickness</code> <code>int  or  str</code> The thickness to set, specified as an integer (1, 2, 3) or a string ('thin', 'bold', 'extra-bold')."},{"location":"api/defaults/#returns_15","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance defaults with updated stroke thickness.</p>"},{"location":"api/diamond/","title":"Class Diamond","text":"<p>A class representing a diamond shape in the diagram. Diamond shape is a four-sided polygon with equal sides and opposite angles equal.</p> <p>[!WARNING] Do not instantiate this class directly. Use <code>SceneBuilder.diamond()</code> instead.</p>"},{"location":"api/diamond/#methods","title":"Methods","text":""},{"location":"api/diamond/#init","title":"init","text":"<p><pre><code>    def __init__(self, defaults: Defaults, listener: AbstractPlainLabelListener, label: str | Text | None = None):\n</code></pre> Initialize self.  See help(type(self)) for accurate signature.</p>"},{"location":"api/diamond/#background","title":"background","text":"<p><pre><code>    def background(self, color: str | Color) -&gt; Self:\n</code></pre> Set the background (fill) color.</p>"},{"location":"api/diamond/#arguments","title":"Arguments","text":"Name Type Description <code>color</code> <code>str  or  Color</code> The background color, specified as a hex string (#RRGGBB), a color name, or a Color object."},{"location":"api/diamond/#returns","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the class for method chaining.</p>"},{"location":"api/diamond/#center","title":"center","text":"<p><pre><code>    def center(self, *args) -&gt; Self | tuple[float, float]:\n</code></pre> Get or set the center coordinates of the element.</p>"},{"location":"api/diamond/#arguments_1","title":"Arguments","text":"Name Type Description <code>*args</code> <code>None</code> Supports two signatures: 1. center() -&gt; tuple[float, float] Returns the (x, y) coordinates of the center. 2. center(x, y) -&gt; Self Sets the center to (x, y) and returns self for chaining."},{"location":"api/diamond/#returns_1","title":"Returns","text":"<p>Type: <code>tuple[float, float]  or  Self</code></p> <p>Depending on the arguments.</p>"},{"location":"api/diamond/#color","title":"color","text":"<p><pre><code>    def color(self, color: str | Color) -&gt; Self:\n</code></pre> Set the stroke (outline) color as #RRGGBB, color name or Color object.</p>"},{"location":"api/diamond/#arguments_2","title":"Arguments","text":"Name Type Description <code>color</code> <code>str  or  Color</code> The color to set, specified as a hex string $RRGGBB, color name, or Color object."},{"location":"api/diamond/#returns_2","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the AbstractStrokedElement class.</p>"},{"location":"api/diamond/#fill","title":"fill","text":"<p><pre><code>    def fill(self, style: str) -&gt; Self:\n</code></pre> Set the fill style for the shape.</p>"},{"location":"api/diamond/#arguments_3","title":"Arguments","text":"Name Type Description <code>style</code> <code>str</code> The fill style to be applied. Must be one of 'hachure', 'cross-hatch', or 'solid'."},{"location":"api/diamond/#returns_3","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the shape with the updated fill style.</p>"},{"location":"api/diamond/#raises","title":"Raises","text":"<p>ValueError: If the provided style is not one of 'hachure', 'cross-hatch', or 'solid'.</p>"},{"location":"api/diamond/#label","title":"label","text":"<p><pre><code>    def label(self, text: Text | str) -&gt; Self:\n</code></pre> Set the label text for the element.</p>"},{"location":"api/diamond/#arguments_4","title":"Arguments","text":"Name Type Description <code>text</code> <code>Text  or  str</code> The text element to set as the label or plain text."},{"location":"api/diamond/#returns_4","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the class.</p>"},{"location":"api/diamond/#link","title":"link","text":"<p><pre><code>    def link(self, target: \"str | AbstractElement\") -&gt; Self:\n</code></pre> Establishes a link to the given target, which can be either a string URL or an AbstractElement instance.</p>"},{"location":"api/diamond/#arguments_5","title":"Arguments","text":"Name Type Description <code>target</code> <code>str  or  AbstractElement</code> The target to link to. If it's an AbstractElement, a URL will be generated using its ID. If it's a string, it will be used directly as the link."},{"location":"api/diamond/#returns_5","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the current object with the updated link.</p>"},{"location":"api/diamond/#raises_1","title":"Raises","text":"<p>ValueError: If the target is neither a string nor an AbstractElement.</p>"},{"location":"api/diamond/#opacity","title":"opacity","text":"<p><pre><code>    def opacity(self, opacity: int) -&gt; Self:\n</code></pre> Set the opacity of the element.</p>"},{"location":"api/diamond/#arguments_6","title":"Arguments","text":"Name Type Description <code>opacity</code> <code>int</code> The opacity value to set, must be in the range 0-100. 100 is fully opaque, 0 is fully transparent."},{"location":"api/diamond/#returns_6","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the element with updated opacity.</p>"},{"location":"api/diamond/#raises_2","title":"Raises","text":"<p>ValueError: If the opacity value is not within the range 0-100.</p>"},{"location":"api/diamond/#orbit","title":"orbit","text":"<p><pre><code>    def orbit(self, *args) -&gt; Self:\n</code></pre> Positions the element relative to a reference using polar coordinates. This method allows placing the element such that its center will be at (radius, angle) from a reference. The reference can be either another AbstractElement or a point (x, y).</p>"},{"location":"api/diamond/#arguments_7","title":"Arguments","text":"Name Type Description <code>*args</code> <code>None</code> Supports two signatures: 1. orbit(element, radius, angle) <code>element</code> <code>AbstractElement</code> The reference element to orbit around. <code>radius</code> <code>float</code> The distance from the center of the reference. <code>angle</code> <code>float</code> The angle to position the element at, in radians."},{"location":"api/diamond/#returns_7","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the element.</p>"},{"location":"api/diamond/#raises_3","title":"Raises","text":"<p>ValueError: If the arguments do not match the expected signatures.</p>"},{"location":"api/diamond/#position","title":"position","text":"<p><pre><code>    def position(self, x: float, y: float) -&gt; Self:\n</code></pre> Sets the position of the element.</p>"},{"location":"api/diamond/#arguments_8","title":"Arguments","text":"Name Type Description <code>x</code> <code>float</code> The x-coordinate of the element. <code>y</code> <code>float</code> The y-coordinate of the element."},{"location":"api/diamond/#returns_8","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the element with updated position.</p>"},{"location":"api/diamond/#rotate","title":"rotate","text":"<p><pre><code>    def rotate(self, angle: float) -&gt; Self:\n</code></pre> Rotate the element clockwise by a specified angle.</p>"},{"location":"api/diamond/#arguments_9","title":"Arguments","text":"Name Type Description <code>angle</code> <code>float</code> The angle to rotate the element clockwise by, in radians."},{"location":"api/diamond/#returns_9","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the element after rotation.</p>"},{"location":"api/diamond/#roundness","title":"roundness","text":"<p><pre><code>    def roundness(self, roundness: str) -&gt; Self:\n</code></pre> Set the roundness style of the shape.</p>"},{"location":"api/diamond/#arguments_10","title":"Arguments","text":"Name Type Description <code>roundness</code> <code>str</code> The roundness style to set. Acceptable values are: - \"sharp\": Sets the shape to have sharp corners. - \"round\": Sets the shape to have rounded corners."},{"location":"api/diamond/#returns_10","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the shape with the updated roundness style.</p>"},{"location":"api/diamond/#raises_4","title":"Raises","text":"<p>ValueError: If the provided roundness style is not \"sharp\" or \"round\".</p>"},{"location":"api/diamond/#size","title":"size","text":"<p><pre><code>    def size(self, width: float, height: float) -&gt; Self:\n</code></pre> Set the size of the diamond.</p>"},{"location":"api/diamond/#arguments_11","title":"Arguments","text":"Name Type Description <code>width</code> <code>float</code> The width of the diamond. <code>height</code> <code>float</code> The height of the diamond."},{"location":"api/diamond/#returns_11","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the diamond with the updated size.</p>"},{"location":"api/diamond/#sloppiness","title":"sloppiness","text":"<p><pre><code>    def sloppiness(self, value: int | str) -&gt; Self:\n</code></pre> Set the stroke sloppiness by int (0, 1, 2) or by string ('architect', 'artist', 'cartoonist').</p>"},{"location":"api/diamond/#arguments_12","title":"Arguments","text":"Name Type Description <code>value</code> <code>int  or  str</code> The sloppiness value to set, specified as an integer (0, 1, 2) or a string ('architect', 'artist', 'cartoonist')."},{"location":"api/diamond/#returns_12","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the AbstractStrokedElement class.</p>"},{"location":"api/diamond/#raises_5","title":"Raises","text":"<p>ValueError: If an invalid sloppiness value is provided.</p>"},{"location":"api/diamond/#stroke","title":"stroke","text":"<p><pre><code>    def stroke(self, style: str) -&gt; Self:\n</code></pre> Set the stroke style (solid, dotted, dashed).</p>"},{"location":"api/diamond/#arguments_13","title":"Arguments","text":"Name Type Description <code>style</code> <code>str</code> The stroke style to set, specified as 'solid', 'dotted', or 'dashed'."},{"location":"api/diamond/#returns_13","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the AbstractStrokedElement class.</p>"},{"location":"api/diamond/#raises_6","title":"Raises","text":"<p>ValueError: If an invalid stroke style is provided.</p>"},{"location":"api/diamond/#thickness","title":"thickness","text":"<p><pre><code>    def thickness(self, thickness: int | str) -&gt; Self:\n</code></pre> Set the stroke thickness by int (1, 2, 3) or by string ('thin', 'bold', 'extra-bold').</p>"},{"location":"api/diamond/#arguments_14","title":"Arguments","text":"Name Type Description <code>thickness</code> <code>int  or  str</code> The thickness to set, specified as an integer (1, 2, 3) or a string ('thin', 'bold', 'extra-bold')."},{"location":"api/diamond/#returns_14","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the AbstractStrokedElement class.</p>"},{"location":"api/diamond/#raises_7","title":"Raises","text":"<p>ValueError: If an invalid thickness value is provided.</p>"},{"location":"api/ellipse/","title":"Class Ellipse","text":"<p>A class representing an elliptical shape element. This class extends both AbstractStrokedElement and AbstractShape to create an ellipse element that can be rendered with stroke properties. The ellipse is defined by its center point and two radii (rx and ry).</p> <p>[!WARNING] Do not instantiate this class directly. Use <code>SceneBuilder.ellipse()</code> instead.</p>"},{"location":"api/ellipse/#methods","title":"Methods","text":""},{"location":"api/ellipse/#init","title":"init","text":"<p><pre><code>    def __init__(self, defaults: Defaults, listener: AbstractPlainLabelListener, label: str | Text | None = None):\n</code></pre> Initialize self.  See help(type(self)) for accurate signature.</p>"},{"location":"api/ellipse/#background","title":"background","text":"<p><pre><code>    def background(self, color: str | Color) -&gt; Self:\n</code></pre> Set the background (fill) color.</p>"},{"location":"api/ellipse/#arguments","title":"Arguments","text":"Name Type Description <code>color</code> <code>str  or  Color</code> The background color, specified as a hex string (#RRGGBB), a color name, or a Color object."},{"location":"api/ellipse/#returns","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the class for method chaining.</p>"},{"location":"api/ellipse/#center","title":"center","text":"<p><pre><code>    def center(self, *args) -&gt; Self | tuple[float, float]:\n</code></pre> Get or set the center coordinates of the element.</p>"},{"location":"api/ellipse/#arguments_1","title":"Arguments","text":"Name Type Description <code>*args</code> <code>None</code> Supports two signatures: 1. center() -&gt; tuple[float, float] Returns the (x, y) coordinates of the center. 2. center(x, y) -&gt; Self Sets the center to (x, y) and returns self for chaining."},{"location":"api/ellipse/#returns_1","title":"Returns","text":"<p>Type: <code>tuple[float, float]  or  Self</code></p> <p>Depending on the arguments.</p>"},{"location":"api/ellipse/#color","title":"color","text":"<p><pre><code>    def color(self, color: str | Color) -&gt; Self:\n</code></pre> Set the stroke (outline) color as #RRGGBB, color name or Color object.</p>"},{"location":"api/ellipse/#arguments_2","title":"Arguments","text":"Name Type Description <code>color</code> <code>str  or  Color</code> The color to set, specified as a hex string $RRGGBB, color name, or Color object."},{"location":"api/ellipse/#returns_2","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the AbstractStrokedElement class.</p>"},{"location":"api/ellipse/#fill","title":"fill","text":"<p><pre><code>    def fill(self, style: str) -&gt; Self:\n</code></pre> Set the fill style for the shape.</p>"},{"location":"api/ellipse/#arguments_3","title":"Arguments","text":"Name Type Description <code>style</code> <code>str</code> The fill style to be applied. Must be one of 'hachure', 'cross-hatch', or 'solid'."},{"location":"api/ellipse/#returns_3","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the shape with the updated fill style.</p>"},{"location":"api/ellipse/#raises","title":"Raises","text":"<p>ValueError: If the provided style is not one of 'hachure', 'cross-hatch', or 'solid'.</p>"},{"location":"api/ellipse/#label","title":"label","text":"<p><pre><code>    def label(self, text: Text | str) -&gt; Self:\n</code></pre> Set the label text for the element.</p>"},{"location":"api/ellipse/#arguments_4","title":"Arguments","text":"Name Type Description <code>text</code> <code>Text  or  str</code> The text element to set as the label or plain text."},{"location":"api/ellipse/#returns_4","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the class.</p>"},{"location":"api/ellipse/#link","title":"link","text":"<p><pre><code>    def link(self, target: \"str | AbstractElement\") -&gt; Self:\n</code></pre> Establishes a link to the given target, which can be either a string URL or an AbstractElement instance.</p>"},{"location":"api/ellipse/#arguments_5","title":"Arguments","text":"Name Type Description <code>target</code> <code>str  or  AbstractElement</code> The target to link to. If it's an AbstractElement, a URL will be generated using its ID. If it's a string, it will be used directly as the link."},{"location":"api/ellipse/#returns_5","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the current object with the updated link.</p>"},{"location":"api/ellipse/#raises_1","title":"Raises","text":"<p>ValueError: If the target is neither a string nor an AbstractElement.</p>"},{"location":"api/ellipse/#opacity","title":"opacity","text":"<p><pre><code>    def opacity(self, opacity: int) -&gt; Self:\n</code></pre> Set the opacity of the element.</p>"},{"location":"api/ellipse/#arguments_6","title":"Arguments","text":"Name Type Description <code>opacity</code> <code>int</code> The opacity value to set, must be in the range 0-100. 100 is fully opaque, 0 is fully transparent."},{"location":"api/ellipse/#returns_6","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the element with updated opacity.</p>"},{"location":"api/ellipse/#raises_2","title":"Raises","text":"<p>ValueError: If the opacity value is not within the range 0-100.</p>"},{"location":"api/ellipse/#orbit","title":"orbit","text":"<p><pre><code>    def orbit(self, *args) -&gt; Self:\n</code></pre> Positions the element relative to a reference using polar coordinates. This method allows placing the element such that its center will be at (radius, angle) from a reference. The reference can be either another AbstractElement or a point (x, y).</p>"},{"location":"api/ellipse/#arguments_7","title":"Arguments","text":"Name Type Description <code>*args</code> <code>None</code> Supports two signatures: 1. orbit(element, radius, angle) <code>element</code> <code>AbstractElement</code> The reference element to orbit around. <code>radius</code> <code>float</code> The distance from the center of the reference. <code>angle</code> <code>float</code> The angle to position the element at, in radians."},{"location":"api/ellipse/#returns_7","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the element.</p>"},{"location":"api/ellipse/#raises_3","title":"Raises","text":"<p>ValueError: If the arguments do not match the expected signatures.</p>"},{"location":"api/ellipse/#position","title":"position","text":"<p><pre><code>    def position(self, x: float, y: float) -&gt; Self:\n</code></pre> Sets the position of the element.</p>"},{"location":"api/ellipse/#arguments_8","title":"Arguments","text":"Name Type Description <code>x</code> <code>float</code> The x-coordinate of the element. <code>y</code> <code>float</code> The y-coordinate of the element."},{"location":"api/ellipse/#returns_8","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the element with updated position.</p>"},{"location":"api/ellipse/#rotate","title":"rotate","text":"<p><pre><code>    def rotate(self, angle: float) -&gt; Self:\n</code></pre> Rotate the element clockwise by a specified angle.</p>"},{"location":"api/ellipse/#arguments_9","title":"Arguments","text":"Name Type Description <code>angle</code> <code>float</code> The angle to rotate the element clockwise by, in radians."},{"location":"api/ellipse/#returns_9","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the element after rotation.</p>"},{"location":"api/ellipse/#size","title":"size","text":"<p><pre><code>    def size(self, width: float, height: float) -&gt; Self:\n</code></pre> Set the size of the ellipse.</p>"},{"location":"api/ellipse/#arguments_10","title":"Arguments","text":"Name Type Description <code>width</code> <code>float</code> The width of the ellipse. <code>height</code> <code>float</code> The height of the ellipse."},{"location":"api/ellipse/#returns_10","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the ellipse with the updated size.</p>"},{"location":"api/ellipse/#sloppiness","title":"sloppiness","text":"<p><pre><code>    def sloppiness(self, value: int | str) -&gt; Self:\n</code></pre> Set the stroke sloppiness by int (0, 1, 2) or by string ('architect', 'artist', 'cartoonist').</p>"},{"location":"api/ellipse/#arguments_11","title":"Arguments","text":"Name Type Description <code>value</code> <code>int  or  str</code> The sloppiness value to set, specified as an integer (0, 1, 2) or a string ('architect', 'artist', 'cartoonist')."},{"location":"api/ellipse/#returns_11","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the AbstractStrokedElement class.</p>"},{"location":"api/ellipse/#raises_4","title":"Raises","text":"<p>ValueError: If an invalid sloppiness value is provided.</p>"},{"location":"api/ellipse/#stroke","title":"stroke","text":"<p><pre><code>    def stroke(self, style: str) -&gt; Self:\n</code></pre> Set the stroke style (solid, dotted, dashed).</p>"},{"location":"api/ellipse/#arguments_12","title":"Arguments","text":"Name Type Description <code>style</code> <code>str</code> The stroke style to set, specified as 'solid', 'dotted', or 'dashed'."},{"location":"api/ellipse/#returns_12","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the AbstractStrokedElement class.</p>"},{"location":"api/ellipse/#raises_5","title":"Raises","text":"<p>ValueError: If an invalid stroke style is provided.</p>"},{"location":"api/ellipse/#thickness","title":"thickness","text":"<p><pre><code>    def thickness(self, thickness: int | str) -&gt; Self:\n</code></pre> Set the stroke thickness by int (1, 2, 3) or by string ('thin', 'bold', 'extra-bold').</p>"},{"location":"api/ellipse/#arguments_13","title":"Arguments","text":"Name Type Description <code>thickness</code> <code>int  or  str</code> The thickness to set, specified as an integer (1, 2, 3) or a string ('thin', 'bold', 'extra-bold')."},{"location":"api/ellipse/#returns_13","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the AbstractStrokedElement class.</p>"},{"location":"api/ellipse/#raises_6","title":"Raises","text":"<p>ValueError: If an invalid thickness value is provided.</p>"},{"location":"api/frame/","title":"Class Frame","text":"<p>A visual container that can hold other elements and automatically adjusts its size. Frame is a fundamental layout component that serves as a container for other elements. It can automatically calculate its dimensions based on its contents or be explicitly sized. Frames can also have titles and background colors, making them useful for grouping related elements and creating visual hierarchies in the layout.</p> <p>[!WARNING] Do not instantiate this class directly. Use <code>SceneBuilder.frame()</code> instead.</p>"},{"location":"api/frame/#methods","title":"Methods","text":""},{"location":"api/frame/#init","title":"init","text":"<p><pre><code>    def __init__(self, defaults: Defaults, title: str | None = None):\n</code></pre> Initialize self.  See help(type(self)) for accurate signature.</p>"},{"location":"api/frame/#background","title":"background","text":"<p><pre><code>    def background(self, color: str | Color) -&gt; Self:\n</code></pre> Set the background (fill) color.</p>"},{"location":"api/frame/#arguments","title":"Arguments","text":"Name Type Description <code>color</code> <code>str  or  Color</code> The background color, specified as a hex string (#RRGGBB), a color name, or a Color object."},{"location":"api/frame/#returns","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the class for method chaining.</p>"},{"location":"api/frame/#center","title":"center","text":"<p><pre><code>    def center(self, *args) -&gt; Self | tuple[float, float]:\n</code></pre> Get or set the center coordinates of the element.</p>"},{"location":"api/frame/#arguments_1","title":"Arguments","text":"Name Type Description <code>*args</code> <code>None</code> Supports two signatures: 1. center() -&gt; tuple[float, float] Returns the (x, y) coordinates of the center. 2. center(x, y) -&gt; Self Sets the center to (x, y) and returns self for chaining."},{"location":"api/frame/#returns_1","title":"Returns","text":"<p>Type: <code>tuple[float, float]  or  Self</code></p> <p>Depending on the arguments.</p>"},{"location":"api/frame/#elements","title":"elements","text":"<p><pre><code>    def elements(self, *elements: AbstractElement) -&gt; Self:\n</code></pre> Add elements to the frame and adjust the frame size accordingly.</p>"},{"location":"api/frame/#arguments_2","title":"Arguments","text":"Name Type Description <code>elements</code> <code>AbstractElement</code> The elements to add to the frame."},{"location":"api/frame/#returns_2","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the Frame class.</p>"},{"location":"api/frame/#fill","title":"fill","text":"<p><pre><code>    def fill(self, style: str) -&gt; Self:\n</code></pre> Set the fill style for the shape.</p>"},{"location":"api/frame/#arguments_3","title":"Arguments","text":"Name Type Description <code>style</code> <code>str</code> The fill style to be applied. Must be one of 'hachure', 'cross-hatch', or 'solid'."},{"location":"api/frame/#returns_3","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the shape with the updated fill style.</p>"},{"location":"api/frame/#raises","title":"Raises","text":"<p>ValueError: If the provided style is not one of 'hachure', 'cross-hatch', or 'solid'.</p>"},{"location":"api/frame/#link","title":"link","text":"<p><pre><code>    def link(self, target: \"str | AbstractElement\") -&gt; Self:\n</code></pre> Establishes a link to the given target, which can be either a string URL or an AbstractElement instance.</p>"},{"location":"api/frame/#arguments_4","title":"Arguments","text":"Name Type Description <code>target</code> <code>str  or  AbstractElement</code> The target to link to. If it's an AbstractElement, a URL will be generated using its ID. If it's a string, it will be used directly as the link."},{"location":"api/frame/#returns_4","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the current object with the updated link.</p>"},{"location":"api/frame/#raises_1","title":"Raises","text":"<p>ValueError: If the target is neither a string nor an AbstractElement.</p>"},{"location":"api/frame/#opacity","title":"opacity","text":"<p><pre><code>    def opacity(self, opacity: int) -&gt; Self:\n</code></pre> Set the opacity of the element.</p>"},{"location":"api/frame/#arguments_5","title":"Arguments","text":"Name Type Description <code>opacity</code> <code>int</code> The opacity value to set, must be in the range 0-100. 100 is fully opaque, 0 is fully transparent."},{"location":"api/frame/#returns_5","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the element with updated opacity.</p>"},{"location":"api/frame/#raises_2","title":"Raises","text":"<p>ValueError: If the opacity value is not within the range 0-100.</p>"},{"location":"api/frame/#orbit","title":"orbit","text":"<p><pre><code>    def orbit(self, *args) -&gt; Self:\n</code></pre> Positions the element relative to a reference using polar coordinates. This method allows placing the element such that its center will be at (radius, angle) from a reference. The reference can be either another AbstractElement or a point (x, y).</p>"},{"location":"api/frame/#arguments_6","title":"Arguments","text":"Name Type Description <code>*args</code> <code>None</code> Supports two signatures: 1. orbit(element, radius, angle) <code>element</code> <code>AbstractElement</code> The reference element to orbit around. <code>radius</code> <code>float</code> The distance from the center of the reference. <code>angle</code> <code>float</code> The angle to position the element at, in radians."},{"location":"api/frame/#returns_6","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the element.</p>"},{"location":"api/frame/#raises_3","title":"Raises","text":"<p>ValueError: If the arguments do not match the expected signatures.</p>"},{"location":"api/frame/#position","title":"position","text":"<p><pre><code>    def position(self, x: float, y: float) -&gt; Self:\n</code></pre> Sets the position of the element.</p>"},{"location":"api/frame/#arguments_7","title":"Arguments","text":"Name Type Description <code>x</code> <code>float</code> The x-coordinate of the element. <code>y</code> <code>float</code> The y-coordinate of the element."},{"location":"api/frame/#returns_7","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the element with updated position.</p>"},{"location":"api/frame/#rotate","title":"rotate","text":"<p><pre><code>    def rotate(self, angle: float) -&gt; Self:\n</code></pre> Rotate the element clockwise by a specified angle.</p>"},{"location":"api/frame/#arguments_8","title":"Arguments","text":"Name Type Description <code>angle</code> <code>float</code> The angle to rotate the element clockwise by, in radians."},{"location":"api/frame/#returns_8","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the element after rotation.</p>"},{"location":"api/frame/#size","title":"size","text":"<p><pre><code>    def size(self, width: float, height: float) -&gt; Self:\n</code></pre> Set the size of the shape.</p>"},{"location":"api/frame/#arguments_9","title":"Arguments","text":"Name Type Description <code>width</code> <code>float</code> The width of the shape. <code>height</code> <code>float</code> The height of the shape."},{"location":"api/frame/#returns_9","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the shape with the updated size.</p>"},{"location":"api/frame/#title","title":"title","text":"<p><pre><code>    def title(self, title: str) -&gt; Self:\n</code></pre> Set the title of the frame.</p>"},{"location":"api/frame/#arguments_10","title":"Arguments","text":"Name Type Description <code>title</code> <code>str</code> The title of the frame."},{"location":"api/frame/#returns_10","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the Frame class.</p>"},{"location":"api/group/","title":"Class Group","text":"<p>A container class that represents a group of elements. This class allows for organizing and managing multiple elements as a single unit. Elements within a group can be manipulated together while maintaining their individual properties. Each group is identified by a unique UUID.</p> <p>[!WARNING] Do not instantiate this class directly. Use <code>SceneBuilder.group()</code> instead.</p>"},{"location":"api/group/#methods","title":"Methods","text":""},{"location":"api/group/#init","title":"init","text":"<p><pre><code>    def __init__(self, defaults: Defaults):\n</code></pre> Initialize self.  See help(type(self)) for accurate signature.</p>"},{"location":"api/group/#elements","title":"elements","text":"<p><pre><code>    def elements(self, *elements: Element) -&gt; Self:\n</code></pre> Add elements to the group.</p>"},{"location":"api/group/#arguments","title":"Arguments","text":"Name Type Description <code>elements</code> <code>Element</code> The elements to add to the group."},{"location":"api/group/#returns","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the Group class.</p>"},{"location":"api/image/","title":"Class Image","text":"<p>A class representing an image element that can be loaded from various sources. This class provides functionality to load and manipulate images from files, URLs, or raw data (bytes/SVG). It supports basic image operations like scaling and fitting within bounds while maintaining aspect ratio.</p> <p>[!WARNING] Do not instantiate this class directly. Use <code>SceneBuilder.image()</code> instead.</p>"},{"location":"api/image/#methods","title":"Methods","text":""},{"location":"api/image/#init","title":"init","text":"<p><pre><code>    def __init__(self, defaults: Defaults, listener: AbstractImageListener, loader: AbstractImageLoader):\n</code></pre> Initialize self.  See help(type(self)) for accurate signature.</p>"},{"location":"api/image/#center","title":"center","text":"<p><pre><code>    def center(self, *args) -&gt; Self | tuple[float, float]:\n</code></pre> Get or set the center coordinates of the element.</p>"},{"location":"api/image/#arguments","title":"Arguments","text":"Name Type Description <code>*args</code> <code>None</code> Supports two signatures: 1. center() -&gt; tuple[float, float] Returns the (x, y) coordinates of the center. 2. center(x, y) -&gt; Self Sets the center to (x, y) and returns self for chaining."},{"location":"api/image/#returns","title":"Returns","text":"<p>Type: <code>tuple[float, float]  or  Self</code></p> <p>Depending on the arguments.</p>"},{"location":"api/image/#data","title":"data","text":"<p><pre><code>    def data(self, data: bytes | str) -&gt; Self:\n</code></pre> Set image data from raw bytes or SVG string.</p>"},{"location":"api/image/#arguments_1","title":"Arguments","text":"Name Type Description <code>data</code> <code>bytes  or  str</code> The raw image data or SVG string."},{"location":"api/image/#returns_1","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the Image class.</p>"},{"location":"api/image/#file","title":"file","text":"<p><pre><code>    def file(self, path: str) -&gt; Self:\n</code></pre> Load image data from a file and set it.</p>"},{"location":"api/image/#arguments_2","title":"Arguments","text":"Name Type Description <code>path</code> <code>str</code> The path to the image file."},{"location":"api/image/#returns_2","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the Image class.</p>"},{"location":"api/image/#fit","title":"fit","text":"<p><pre><code>    def fit(self, max_width: float, max_height: float) -&gt; Self:\n</code></pre> Scale the image to fit within a bounding box while maintaining aspect ratio.</p>"},{"location":"api/image/#arguments_3","title":"Arguments","text":"Name Type Description <code>max_width</code> <code>float</code> The maximum width of the bounding box. <code>max_height</code> <code>float</code> The maximum height of the bounding box."},{"location":"api/image/#returns_3","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the Image class.</p>"},{"location":"api/image/#link","title":"link","text":"<p><pre><code>    def link(self, target: \"str | AbstractElement\") -&gt; Self:\n</code></pre> Establishes a link to the given target, which can be either a string URL or an AbstractElement instance.</p>"},{"location":"api/image/#arguments_4","title":"Arguments","text":"Name Type Description <code>target</code> <code>str  or  AbstractElement</code> The target to link to. If it's an AbstractElement, a URL will be generated using its ID. If it's a string, it will be used directly as the link."},{"location":"api/image/#returns_4","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the current object with the updated link.</p>"},{"location":"api/image/#raises","title":"Raises","text":"<p>ValueError: If the target is neither a string nor an AbstractElement.</p>"},{"location":"api/image/#opacity","title":"opacity","text":"<p><pre><code>    def opacity(self, opacity: int) -&gt; Self:\n</code></pre> Set the opacity of the element.</p>"},{"location":"api/image/#arguments_5","title":"Arguments","text":"Name Type Description <code>opacity</code> <code>int</code> The opacity value to set, must be in the range 0-100. 100 is fully opaque, 0 is fully transparent."},{"location":"api/image/#returns_5","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the element with updated opacity.</p>"},{"location":"api/image/#raises_1","title":"Raises","text":"<p>ValueError: If the opacity value is not within the range 0-100.</p>"},{"location":"api/image/#orbit","title":"orbit","text":"<p><pre><code>    def orbit(self, *args) -&gt; Self:\n</code></pre> Positions the element relative to a reference using polar coordinates. This method allows placing the element such that its center will be at (radius, angle) from a reference. The reference can be either another AbstractElement or a point (x, y).</p>"},{"location":"api/image/#arguments_6","title":"Arguments","text":"Name Type Description <code>*args</code> <code>None</code> Supports two signatures: 1. orbit(element, radius, angle) <code>element</code> <code>AbstractElement</code> The reference element to orbit around. <code>radius</code> <code>float</code> The distance from the center of the reference. <code>angle</code> <code>float</code> The angle to position the element at, in radians."},{"location":"api/image/#returns_6","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the element.</p>"},{"location":"api/image/#raises_2","title":"Raises","text":"<p>ValueError: If the arguments do not match the expected signatures.</p>"},{"location":"api/image/#position","title":"position","text":"<p><pre><code>    def position(self, x: float, y: float) -&gt; Self:\n</code></pre> Sets the position of the element.</p>"},{"location":"api/image/#arguments_7","title":"Arguments","text":"Name Type Description <code>x</code> <code>float</code> The x-coordinate of the element. <code>y</code> <code>float</code> The y-coordinate of the element."},{"location":"api/image/#returns_7","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the element with updated position.</p>"},{"location":"api/image/#rotate","title":"rotate","text":"<p><pre><code>    def rotate(self, angle: float) -&gt; Self:\n</code></pre> Rotate the element clockwise by a specified angle.</p>"},{"location":"api/image/#arguments_8","title":"Arguments","text":"Name Type Description <code>angle</code> <code>float</code> The angle to rotate the element clockwise by, in radians."},{"location":"api/image/#returns_8","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the element after rotation.</p>"},{"location":"api/image/#size","title":"size","text":"<p><pre><code>    def size(self, *args) -&gt; Self | tuple[float, float]:\n</code></pre> Get or set the size of the element.</p>"},{"location":"api/image/#arguments_9","title":"Arguments","text":"Name Type Description <code>*args</code> <code>None</code> Supports two signatures: 1. size() -&gt; tuple[float, float] Returns the (width, height) of the element. 2. size(width, height) -&gt; Self Sets the size to (width, height) and returns self for chaining."},{"location":"api/image/#returns_9","title":"Returns","text":"<p>Type: <code>tuple[float, float]  or  Self</code></p> <p>Depending on the arguments.</p>"},{"location":"api/image/#url","title":"url","text":"<p><pre><code>    def url(self, url: str) -&gt; Self:\n</code></pre> Load image data from a URL and set it.</p>"},{"location":"api/image/#arguments_10","title":"Arguments","text":"Name Type Description <code>url</code> <code>str</code> The URL to the image."},{"location":"api/image/#returns_10","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the Image class.</p>"},{"location":"api/line/","title":"Class Line","text":"<p>A line element that draws a straight or curved line segments between the given points. This class represents a line element in the drawing canvas. It provides functionality for creating and manipulating straight pr curved lines with specified configurations for styling and positioning.</p> <p>[!WARNING] Do not instantiate this class directly. Use <code>SceneBuilder.line()</code> instead.</p>"},{"location":"api/line/#methods","title":"Methods","text":""},{"location":"api/line/#init","title":"init","text":"<p><pre><code>    def __init__(self, defaults: Defaults):\n</code></pre> Initialize self.  See help(type(self)) for accurate signature.</p>"},{"location":"api/line/#append","title":"append","text":"<p><pre><code>    def append(self, points: list[Point]) -&gt; Self:\n</code></pre> Appends points to the line.</p>"},{"location":"api/line/#arguments","title":"Arguments","text":"Name Type Description <code>points</code> <code>list[Point]</code> A list of Point objects to append. Returns: Self: The instance of the class with updated points, width, and height."},{"location":"api/line/#arc","title":"arc","text":"<p><pre><code>    def arc(self, x: float, y: float, radius: float, start_angle: float, angle_span: float) -&gt; Self:\n</code></pre> Adds an arc to the line. Approximates an arc between two points, given by the center of the arc, radius, start angle and angle span.</p>"},{"location":"api/line/#arguments_1","title":"Arguments","text":"Name Type Description <code>x</code> <code>float</code> The x-coordinate of the center of the arc. <code>y</code> <code>float</code> The y-coordinate of the center of the arc. <code>radius</code> <code>float</code> The radius of the arc. <code>start_angle</code> <code>float</code> The starting angle of the arc, in radians. <code>angle_span</code> <code>float</code> The angle span of the arc, in radians."},{"location":"api/line/#returns","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the class for method chaining.</p>"},{"location":"api/line/#background","title":"background","text":"<p><pre><code>    def background(self, color: str | Color) -&gt; Self:\n</code></pre> Set the background (fill) color of the shape created by a closed line segments.</p>"},{"location":"api/line/#arguments_2","title":"Arguments","text":"Name Type Description <code>color</code> <code>str  or  Color</code> The background color, specified as a hex string (#RRGGBB), a color name, or a Color object."},{"location":"api/line/#returns_1","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the class for method chaining.</p>"},{"location":"api/line/#center","title":"center","text":"<p><pre><code>    def center(self, *args) -&gt; Self | tuple[float, float]:\n</code></pre> Get or set the center coordinates of the element.</p>"},{"location":"api/line/#arguments_3","title":"Arguments","text":"Name Type Description <code>*args</code> <code>None</code> Supports two signatures: 1. center() -&gt; tuple[float, float] Returns the (x, y) coordinates of the center. 2. center(x, y) -&gt; Self Sets the center to (x, y) and returns self for chaining."},{"location":"api/line/#returns_2","title":"Returns","text":"<p>Type: <code>tuple[float, float]  or  Self</code></p> <p>Depending on the arguments.</p>"},{"location":"api/line/#close","title":"close","text":"<p><pre><code>    def close(self):\n</code></pre> Close the line by connecting the last point to the first point.</p>"},{"location":"api/line/#color","title":"color","text":"<p><pre><code>    def color(self, color: str | Color) -&gt; Self:\n</code></pre> Set the stroke (outline) color as #RRGGBB, color name or Color object.</p>"},{"location":"api/line/#arguments_4","title":"Arguments","text":"Name Type Description <code>color</code> <code>str  or  Color</code> The color to set, specified as a hex string $RRGGBB, color name, or Color object."},{"location":"api/line/#returns_3","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the AbstractStrokedElement class.</p>"},{"location":"api/line/#fill","title":"fill","text":"<p><pre><code>    def fill(self, style: str) -&gt; Self:\n</code></pre> Set the fill style for the shape created by a closed line segments.</p>"},{"location":"api/line/#arguments_5","title":"Arguments","text":"Name Type Description <code>style</code> <code>str</code> The fill style to be applied. Must be one of 'hachure', 'cross-hatch', or 'solid'."},{"location":"api/line/#returns_4","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the shape with the updated fill style.</p>"},{"location":"api/line/#raises","title":"Raises","text":"<p>ValueError: If the provided style is not one of 'hachure', 'cross-hatch', or 'solid'.</p>"},{"location":"api/line/#link","title":"link","text":"<p><pre><code>    def link(self, target: \"str | AbstractElement\") -&gt; Self:\n</code></pre> Establishes a link to the given target, which can be either a string URL or an AbstractElement instance.</p>"},{"location":"api/line/#arguments_6","title":"Arguments","text":"Name Type Description <code>target</code> <code>str  or  AbstractElement</code> The target to link to. If it's an AbstractElement, a URL will be generated using its ID. If it's a string, it will be used directly as the link."},{"location":"api/line/#returns_5","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the current object with the updated link.</p>"},{"location":"api/line/#raises_1","title":"Raises","text":"<p>ValueError: If the target is neither a string nor an AbstractElement.</p>"},{"location":"api/line/#opacity","title":"opacity","text":"<p><pre><code>    def opacity(self, opacity: int) -&gt; Self:\n</code></pre> Set the opacity of the element.</p>"},{"location":"api/line/#arguments_7","title":"Arguments","text":"Name Type Description <code>opacity</code> <code>int</code> The opacity value to set, must be in the range 0-100. 100 is fully opaque, 0 is fully transparent."},{"location":"api/line/#returns_6","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the element with updated opacity.</p>"},{"location":"api/line/#raises_2","title":"Raises","text":"<p>ValueError: If the opacity value is not within the range 0-100.</p>"},{"location":"api/line/#orbit","title":"orbit","text":"<p><pre><code>    def orbit(self, *args) -&gt; Self:\n</code></pre> Positions the element relative to a reference using polar coordinates. This method allows placing the element such that its center will be at (radius, angle) from a reference. The reference can be either another AbstractElement or a point (x, y).</p>"},{"location":"api/line/#arguments_8","title":"Arguments","text":"Name Type Description <code>*args</code> <code>None</code> Supports two signatures: 1. orbit(element, radius, angle) <code>element</code> <code>AbstractElement</code> The reference element to orbit around. <code>radius</code> <code>float</code> The distance from the center of the reference. <code>angle</code> <code>float</code> The angle to position the element at, in radians."},{"location":"api/line/#returns_7","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the element.</p>"},{"location":"api/line/#raises_3","title":"Raises","text":"<p>ValueError: If the arguments do not match the expected signatures.</p>"},{"location":"api/line/#points","title":"points","text":"<p><pre><code>    def points(self, points: list[Point]) -&gt; Self:\n</code></pre> Sets the points for the line and calculates the width and height.</p>"},{"location":"api/line/#arguments_9","title":"Arguments","text":"Name Type Description <code>points</code> <code>list[Point]</code> A list of Point objects representing the coordinates of the line. Returns: Self: The instance of the class with updated points, width, and height."},{"location":"api/line/#position","title":"position","text":"<p><pre><code>    def position(self, x: float, y: float) -&gt; Self:\n</code></pre> Sets the position of the element.</p>"},{"location":"api/line/#arguments_10","title":"Arguments","text":"Name Type Description <code>x</code> <code>float</code> The x-coordinate of the element. <code>y</code> <code>float</code> The y-coordinate of the element."},{"location":"api/line/#returns_8","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the element with updated position.</p>"},{"location":"api/line/#prepend","title":"prepend","text":"<p><pre><code>    def prepend(self, points: list[Point]) -&gt; Self:\n</code></pre> Prepends points to the line.</p>"},{"location":"api/line/#arguments_11","title":"Arguments","text":"Name Type Description <code>points</code> <code>list[Point]</code> A list of Point objects to prepend. Returns: Self: The instance of the class with updated points, width, and height."},{"location":"api/line/#rotate","title":"rotate","text":"<p><pre><code>    def rotate(self, angle: float) -&gt; Self:\n</code></pre> Rotate the element clockwise by a specified angle.</p>"},{"location":"api/line/#arguments_12","title":"Arguments","text":"Name Type Description <code>angle</code> <code>float</code> The angle to rotate the element clockwise by, in radians."},{"location":"api/line/#returns_9","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the element after rotation.</p>"},{"location":"api/line/#roundness","title":"roundness","text":"<p><pre><code>    def roundness(self, roundness: str) -&gt; Self:\n</code></pre> Set the roundness style of the shape.</p>"},{"location":"api/line/#arguments_13","title":"Arguments","text":"Name Type Description <code>roundness</code> <code>str</code> The roundness style to set. Acceptable values are: - \"sharp\": Sets the shape to have sharp corners. - \"round\": Sets the shape to have rounded corners."},{"location":"api/line/#returns_10","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the shape with the updated roundness style.</p>"},{"location":"api/line/#raises_4","title":"Raises","text":"<p>ValueError: If the provided roundness style is not \"sharp\" or \"round\".</p>"},{"location":"api/line/#size","title":"size","text":"<p><pre><code>    def size(self, width: float, height: float) -&gt; Self:\n</code></pre> Set the size of the shape.</p>"},{"location":"api/line/#arguments_14","title":"Arguments","text":"Name Type Description <code>width</code> <code>float</code> The width of the shape. <code>height</code> <code>float</code> The height of the shape."},{"location":"api/line/#returns_11","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the shape with the updated size.</p>"},{"location":"api/line/#sloppiness","title":"sloppiness","text":"<p><pre><code>    def sloppiness(self, value: int | str) -&gt; Self:\n</code></pre> Set the stroke sloppiness by int (0, 1, 2) or by string ('architect', 'artist', 'cartoonist').</p>"},{"location":"api/line/#arguments_15","title":"Arguments","text":"Name Type Description <code>value</code> <code>int  or  str</code> The sloppiness value to set, specified as an integer (0, 1, 2) or a string ('architect', 'artist', 'cartoonist')."},{"location":"api/line/#returns_12","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the AbstractStrokedElement class.</p>"},{"location":"api/line/#raises_5","title":"Raises","text":"<p>ValueError: If an invalid sloppiness value is provided.</p>"},{"location":"api/line/#stroke","title":"stroke","text":"<p><pre><code>    def stroke(self, style: str) -&gt; Self:\n</code></pre> Set the stroke style (solid, dotted, dashed).</p>"},{"location":"api/line/#arguments_16","title":"Arguments","text":"Name Type Description <code>style</code> <code>str</code> The stroke style to set, specified as 'solid', 'dotted', or 'dashed'."},{"location":"api/line/#returns_13","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the AbstractStrokedElement class.</p>"},{"location":"api/line/#raises_6","title":"Raises","text":"<p>ValueError: If an invalid stroke style is provided.</p>"},{"location":"api/line/#thickness","title":"thickness","text":"<p><pre><code>    def thickness(self, thickness: int | str) -&gt; Self:\n</code></pre> Set the stroke thickness by int (1, 2, 3) or by string ('thin', 'bold', 'extra-bold').</p>"},{"location":"api/line/#arguments_17","title":"Arguments","text":"Name Type Description <code>thickness</code> <code>int  or  str</code> The thickness to set, specified as an integer (1, 2, 3) or a string ('thin', 'bold', 'extra-bold')."},{"location":"api/line/#returns_14","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the AbstractStrokedElement class.</p>"},{"location":"api/line/#raises_7","title":"Raises","text":"<p>ValueError: If an invalid thickness value is provided.</p>"},{"location":"api/rectangle/","title":"Class Rectangle","text":"<p>A class representing a rectangular shape in a 2D space. The rectangle is defined by its position and dimensions, and can be configured with various visual properties through the config parameter.</p> <p>[!WARNING] Do not instantiate this class directly. Use <code>SceneBuilder.rectangle()</code> instead.</p>"},{"location":"api/rectangle/#methods","title":"Methods","text":""},{"location":"api/rectangle/#init","title":"init","text":"<p><pre><code>    def __init__(self, defaults: Defaults, listener: AbstractPlainLabelListener, label: str | Text | None = None):\n</code></pre> Initialize self.  See help(type(self)) for accurate signature.</p>"},{"location":"api/rectangle/#background","title":"background","text":"<p><pre><code>    def background(self, color: str | Color) -&gt; Self:\n</code></pre> Set the background (fill) color.</p>"},{"location":"api/rectangle/#arguments","title":"Arguments","text":"Name Type Description <code>color</code> <code>str  or  Color</code> The background color, specified as a hex string (#RRGGBB), a color name, or a Color object."},{"location":"api/rectangle/#returns","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the class for method chaining.</p>"},{"location":"api/rectangle/#center","title":"center","text":"<p><pre><code>    def center(self, *args) -&gt; Self | tuple[float, float]:\n</code></pre> Get or set the center coordinates of the element.</p>"},{"location":"api/rectangle/#arguments_1","title":"Arguments","text":"Name Type Description <code>*args</code> <code>None</code> Supports two signatures: 1. center() -&gt; tuple[float, float] Returns the (x, y) coordinates of the center. 2. center(x, y) -&gt; Self Sets the center to (x, y) and returns self for chaining."},{"location":"api/rectangle/#returns_1","title":"Returns","text":"<p>Type: <code>tuple[float, float]  or  Self</code></p> <p>Depending on the arguments.</p>"},{"location":"api/rectangle/#color","title":"color","text":"<p><pre><code>    def color(self, color: str | Color) -&gt; Self:\n</code></pre> Set the stroke (outline) color as #RRGGBB, color name or Color object.</p>"},{"location":"api/rectangle/#arguments_2","title":"Arguments","text":"Name Type Description <code>color</code> <code>str  or  Color</code> The color to set, specified as a hex string $RRGGBB, color name, or Color object."},{"location":"api/rectangle/#returns_2","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the AbstractStrokedElement class.</p>"},{"location":"api/rectangle/#fill","title":"fill","text":"<p><pre><code>    def fill(self, style: str) -&gt; Self:\n</code></pre> Set the fill style for the shape.</p>"},{"location":"api/rectangle/#arguments_3","title":"Arguments","text":"Name Type Description <code>style</code> <code>str</code> The fill style to be applied. Must be one of 'hachure', 'cross-hatch', or 'solid'."},{"location":"api/rectangle/#returns_3","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the shape with the updated fill style.</p>"},{"location":"api/rectangle/#raises","title":"Raises","text":"<p>ValueError: If the provided style is not one of 'hachure', 'cross-hatch', or 'solid'.</p>"},{"location":"api/rectangle/#label","title":"label","text":"<p><pre><code>    def label(self, text: Text | str) -&gt; Self:\n</code></pre> Set the label text for the element.</p>"},{"location":"api/rectangle/#arguments_4","title":"Arguments","text":"Name Type Description <code>text</code> <code>Text  or  str</code> The text element to set as the label or plain text."},{"location":"api/rectangle/#returns_4","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the class.</p>"},{"location":"api/rectangle/#link","title":"link","text":"<p><pre><code>    def link(self, target: \"str | AbstractElement\") -&gt; Self:\n</code></pre> Establishes a link to the given target, which can be either a string URL or an AbstractElement instance.</p>"},{"location":"api/rectangle/#arguments_5","title":"Arguments","text":"Name Type Description <code>target</code> <code>str  or  AbstractElement</code> The target to link to. If it's an AbstractElement, a URL will be generated using its ID. If it's a string, it will be used directly as the link."},{"location":"api/rectangle/#returns_5","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the current object with the updated link.</p>"},{"location":"api/rectangle/#raises_1","title":"Raises","text":"<p>ValueError: If the target is neither a string nor an AbstractElement.</p>"},{"location":"api/rectangle/#opacity","title":"opacity","text":"<p><pre><code>    def opacity(self, opacity: int) -&gt; Self:\n</code></pre> Set the opacity of the element.</p>"},{"location":"api/rectangle/#arguments_6","title":"Arguments","text":"Name Type Description <code>opacity</code> <code>int</code> The opacity value to set, must be in the range 0-100. 100 is fully opaque, 0 is fully transparent."},{"location":"api/rectangle/#returns_6","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the element with updated opacity.</p>"},{"location":"api/rectangle/#raises_2","title":"Raises","text":"<p>ValueError: If the opacity value is not within the range 0-100.</p>"},{"location":"api/rectangle/#orbit","title":"orbit","text":"<p><pre><code>    def orbit(self, *args) -&gt; Self:\n</code></pre> Positions the element relative to a reference using polar coordinates. This method allows placing the element such that its center will be at (radius, angle) from a reference. The reference can be either another AbstractElement or a point (x, y).</p>"},{"location":"api/rectangle/#arguments_7","title":"Arguments","text":"Name Type Description <code>*args</code> <code>None</code> Supports two signatures: 1. orbit(element, radius, angle) <code>element</code> <code>AbstractElement</code> The reference element to orbit around. <code>radius</code> <code>float</code> The distance from the center of the reference. <code>angle</code> <code>float</code> The angle to position the element at, in radians."},{"location":"api/rectangle/#returns_7","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the element.</p>"},{"location":"api/rectangle/#raises_3","title":"Raises","text":"<p>ValueError: If the arguments do not match the expected signatures.</p>"},{"location":"api/rectangle/#position","title":"position","text":"<p><pre><code>    def position(self, x: float, y: float) -&gt; Self:\n</code></pre> Sets the position of the element.</p>"},{"location":"api/rectangle/#arguments_8","title":"Arguments","text":"Name Type Description <code>x</code> <code>float</code> The x-coordinate of the element. <code>y</code> <code>float</code> The y-coordinate of the element."},{"location":"api/rectangle/#returns_8","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the element with updated position.</p>"},{"location":"api/rectangle/#rotate","title":"rotate","text":"<p><pre><code>    def rotate(self, angle: float) -&gt; Self:\n</code></pre> Rotate the element clockwise by a specified angle.</p>"},{"location":"api/rectangle/#arguments_9","title":"Arguments","text":"Name Type Description <code>angle</code> <code>float</code> The angle to rotate the element clockwise by, in radians."},{"location":"api/rectangle/#returns_9","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the element after rotation.</p>"},{"location":"api/rectangle/#roundness","title":"roundness","text":"<p><pre><code>    def roundness(self, roundness: str) -&gt; Self:\n</code></pre> Set the roundness style of the shape.</p>"},{"location":"api/rectangle/#arguments_10","title":"Arguments","text":"Name Type Description <code>roundness</code> <code>str</code> The roundness style to set. Acceptable values are: - \"sharp\": Sets the shape to have sharp corners. - \"round\": Sets the shape to have rounded corners."},{"location":"api/rectangle/#returns_10","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the shape with the updated roundness style.</p>"},{"location":"api/rectangle/#raises_4","title":"Raises","text":"<p>ValueError: If the provided roundness style is not \"sharp\" or \"round\".</p>"},{"location":"api/rectangle/#size","title":"size","text":"<p><pre><code>    def size(self, width: float, height: float) -&gt; Self:\n</code></pre> Set the size of the rectangle.</p>"},{"location":"api/rectangle/#arguments_11","title":"Arguments","text":"Name Type Description <code>width</code> <code>float</code> The width of the rectangle. <code>height</code> <code>float</code> The height of the rectangle."},{"location":"api/rectangle/#returns_11","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the rectangle with the updated size.</p>"},{"location":"api/rectangle/#sloppiness","title":"sloppiness","text":"<p><pre><code>    def sloppiness(self, value: int | str) -&gt; Self:\n</code></pre> Set the stroke sloppiness by int (0, 1, 2) or by string ('architect', 'artist', 'cartoonist').</p>"},{"location":"api/rectangle/#arguments_12","title":"Arguments","text":"Name Type Description <code>value</code> <code>int  or  str</code> The sloppiness value to set, specified as an integer (0, 1, 2) or a string ('architect', 'artist', 'cartoonist')."},{"location":"api/rectangle/#returns_12","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the AbstractStrokedElement class.</p>"},{"location":"api/rectangle/#raises_5","title":"Raises","text":"<p>ValueError: If an invalid sloppiness value is provided.</p>"},{"location":"api/rectangle/#stroke","title":"stroke","text":"<p><pre><code>    def stroke(self, style: str) -&gt; Self:\n</code></pre> Set the stroke style (solid, dotted, dashed).</p>"},{"location":"api/rectangle/#arguments_13","title":"Arguments","text":"Name Type Description <code>style</code> <code>str</code> The stroke style to set, specified as 'solid', 'dotted', or 'dashed'."},{"location":"api/rectangle/#returns_13","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the AbstractStrokedElement class.</p>"},{"location":"api/rectangle/#raises_6","title":"Raises","text":"<p>ValueError: If an invalid stroke style is provided.</p>"},{"location":"api/rectangle/#thickness","title":"thickness","text":"<p><pre><code>    def thickness(self, thickness: int | str) -&gt; Self:\n</code></pre> Set the stroke thickness by int (1, 2, 3) or by string ('thin', 'bold', 'extra-bold').</p>"},{"location":"api/rectangle/#arguments_14","title":"Arguments","text":"Name Type Description <code>thickness</code> <code>int  or  str</code> The thickness to set, specified as an integer (1, 2, 3) or a string ('thin', 'bold', 'extra-bold')."},{"location":"api/rectangle/#returns_14","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the AbstractStrokedElement class.</p>"},{"location":"api/rectangle/#raises_7","title":"Raises","text":"<p>ValueError: If an invalid thickness value is provided.</p>"},{"location":"api/scenebuilder/","title":"Class SceneBuilder","text":"<p>The SceneBuilder class provides methods to add various diagram elements. The elemnts include rectangles, diamonds, ellipses, arrows, lines, text, images, groups, and frames. Additionally, it offers serialization of the diagram to JSON and allows saving it to a file. The fluent API allows chaining method calls for a more concise code.</p>"},{"location":"api/scenebuilder/#methods","title":"Methods","text":""},{"location":"api/scenebuilder/#init","title":"init","text":"<p><pre><code>    def __init__(self):\n</code></pre> Initialize self.  See help(type(self)) for accurate signature.</p>"},{"location":"api/scenebuilder/#arrow","title":"arrow","text":"<p><pre><code>    def arrow(self, label: str | Text | None = None) -&gt; Arrow:\n</code></pre> Add an arrow element to the diagram.</p>"},{"location":"api/scenebuilder/#arguments","title":"Arguments","text":"Name Type Description <code>label</code> <code>str  or  Text  or  None</code> The text label for the arrow."},{"location":"api/scenebuilder/#returns","title":"Returns","text":"<p>Type: <code>Arrow</code></p> <p>The Arrow element.</p>"},{"location":"api/scenebuilder/#background","title":"background","text":"<p><pre><code>    def background(self, color: str) -&gt; Self:\n</code></pre> Set the background color of the diagram.</p>"},{"location":"api/scenebuilder/#arguments_1","title":"Arguments","text":"Name Type Description <code>color</code> <code>str</code> The background color."},{"location":"api/scenebuilder/#returns_1","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the Excaligen class.</p>"},{"location":"api/scenebuilder/#color","title":"color","text":"<p><pre><code>    def color(self) -&gt; Color:\n</code></pre> Create a color object. It can be used as an argument for setting stroke and background colors.</p>"},{"location":"api/scenebuilder/#returns_2","title":"Returns","text":"<p>Type: <code>Color</code></p> <p>The Color object.</p>"},{"location":"api/scenebuilder/#defaults","title":"defaults","text":"<p><pre><code>    def defaults(self) -&gt; Defaults:\n</code></pre> Retrieve the default parameters for elements.</p>"},{"location":"api/scenebuilder/#returns_3","title":"Returns","text":"<p>Type: <code>Defaults</code></p> <p>The Defaults parameters for elements.</p>"},{"location":"api/scenebuilder/#diamond","title":"diamond","text":"<p><pre><code>    def diamond(self, label: str | Text | None = None) -&gt; Diamond:\n</code></pre> Add a diamond element to the diagram.</p>"},{"location":"api/scenebuilder/#arguments_2","title":"Arguments","text":"Name Type Description <code>label</code> <code>str  or  Text  or  None</code> The text label for the diamond."},{"location":"api/scenebuilder/#returns_4","title":"Returns","text":"<p>Type: <code>Diamond</code></p> <p>The Diamond element.</p>"},{"location":"api/scenebuilder/#ellipse","title":"ellipse","text":"<p><pre><code>    def ellipse(self, label: str | Text | None = None) -&gt; Ellipse:\n</code></pre> Add an ellipse element to the diagram.</p>"},{"location":"api/scenebuilder/#arguments_3","title":"Arguments","text":"Name Type Description <code>label</code> <code>str  or  Text  or  None</code> The text label for the ellipse."},{"location":"api/scenebuilder/#returns_5","title":"Returns","text":"<p>Type: <code>Ellipse</code></p> <p>The Ellipse element.</p>"},{"location":"api/scenebuilder/#frame","title":"frame","text":"<p><pre><code>    def frame(self, title: str | None = None) -&gt; Frame:\n</code></pre> Add a frame element to the diagram.</p>"},{"location":"api/scenebuilder/#arguments_4","title":"Arguments","text":"Name Type Description <code>title</code> <code>str  or  None</code> The title of the frame."},{"location":"api/scenebuilder/#returns_6","title":"Returns","text":"<p>Type: <code>Frame</code></p> <p>The Frame element.</p>"},{"location":"api/scenebuilder/#grid","title":"grid","text":"<p><pre><code>    def grid(self, size: int, step: int, enabled: bool) -&gt; Self:\n</code></pre> Set the grid properties for the diagram.</p>"},{"location":"api/scenebuilder/#arguments_5","title":"Arguments","text":"Name Type Description <code>size</code> <code>int</code> The size of the grid. <code>step</code> <code>int</code> The step size of the grid. <code>enabled</code> <code>bool</code> Whether the grid is enabled."},{"location":"api/scenebuilder/#returns_7","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the Excaligen class.</p>"},{"location":"api/scenebuilder/#group","title":"group","text":"<p><pre><code>    def group(self) -&gt; Group:\n</code></pre> Generate a group (virtual container).</p>"},{"location":"api/scenebuilder/#returns_8","title":"Returns","text":"<p>Type: <code>Group</code></p> <p>The Group container.</p>"},{"location":"api/scenebuilder/#image","title":"image","text":"<p><pre><code>    def image(self) -&gt; Image:\n</code></pre> Add an image element to the diagram.</p>"},{"location":"api/scenebuilder/#returns_9","title":"Returns","text":"<p>Type: <code>Image</code></p> <p>The Image element.</p>"},{"location":"api/scenebuilder/#json","title":"json","text":"<p><pre><code>    def json(self) -&gt; str:\n</code></pre> Serialize the diagram to a JSON string.</p>"},{"location":"api/scenebuilder/#returns_10","title":"Returns","text":"<p>Type: <code>str</code></p> <p>The JSON representation of the diagram.</p>"},{"location":"api/scenebuilder/#line","title":"line","text":"<p><pre><code>    def line(self) -&gt; Line:\n</code></pre> Add a line element to the diagram.</p>"},{"location":"api/scenebuilder/#returns_11","title":"Returns","text":"<p>Type: <code>Line</code></p> <p>The Line element.</p>"},{"location":"api/scenebuilder/#rectangle","title":"rectangle","text":"<p><pre><code>    def rectangle(self, label: str | Text | None = None) -&gt; Rectangle:\n</code></pre> Add a rectangle element to the diagram.</p>"},{"location":"api/scenebuilder/#arguments_6","title":"Arguments","text":"Name Type Description <code>label</code> <code>str  or  Text  or  None</code> The text label for the rectangle."},{"location":"api/scenebuilder/#returns_12","title":"Returns","text":"<p>Type: <code>Rectangle</code></p> <p>The Rectangle element.</p>"},{"location":"api/scenebuilder/#save","title":"save","text":"<p><pre><code>    def save(self, file: str) -&gt; Self:\n</code></pre> Save the current diagram to a file.</p>"},{"location":"api/scenebuilder/#arguments_7","title":"Arguments","text":"Name Type Description <code>file</code> <code>str</code> The path to the file where the diagram will be saved."},{"location":"api/scenebuilder/#returns_13","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the Excaligen class.</p>"},{"location":"api/scenebuilder/#text","title":"text","text":"<p><pre><code>    def text(self, text: str | None = None) -&gt; Text:\n</code></pre> Add a text element to the diagram.</p>"},{"location":"api/scenebuilder/#arguments_8","title":"Arguments","text":"Name Type Description <code>text</code> <code>str  or  None</code> The text string."},{"location":"api/scenebuilder/#returns_14","title":"Returns","text":"<p>Type: <code>Text</code></p> <p>The Text element.</p>"},{"location":"api/text/","title":"Class Text","text":"<p>A class representing text elements in excaligen. The Text class is designed to handle and manipulate text elements within the excaligen framework. It provides various text customization options including font styles, sizes, alignments, and colors. The class supports auto-resizing capabilities and multiple font families.</p> <p>[!WARNING] Do not instantiate this class directly. Use <code>SceneBuilder.text()</code> instead.</p>"},{"location":"api/text/#methods","title":"Methods","text":""},{"location":"api/text/#init","title":"init","text":"<p><pre><code>    def __init__(self, defaults: Defaults, text: str | None = None):\n</code></pre> Initialize self.  See help(type(self)) for accurate signature.</p>"},{"location":"api/text/#align","title":"align","text":"<p><pre><code>    def align(self, align: str) -&gt; Self:\n</code></pre> Set the horizontal text alignment (left, center, right).</p>"},{"location":"api/text/#arguments","title":"Arguments","text":"Name Type Description <code>align</code> <code>str</code> The horizontal alignment to set."},{"location":"api/text/#returns","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the Text class.</p>"},{"location":"api/text/#raises","title":"Raises","text":"<p>ValueError: If an invalid alignment is provided.</p>"},{"location":"api/text/#anchor","title":"anchor","text":"<p><pre><code>    def anchor(self, x: float, y: float, align: str | None = None, baseline: str | None = None) -&gt; Self:\n</code></pre> Anchor the text element to a specific point (x, y). It takes horizontal and vertical alignment into account.</p>"},{"location":"api/text/#arguments_1","title":"Arguments","text":"Name Type Description <code>x</code> <code>float</code> The x-coordinate to anchor to. <code>y</code> <code>float</code> The y-coordinate to anchor to. <code>align</code> <code>str  or  None, optional</code> The horizontal alignment ('left', 'center', 'right'). <code>baseline</code> <code>str  or  None, optional</code> The vertical alignment ('top', 'middle', 'bottom')."},{"location":"api/text/#returns_1","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the Text class.</p>"},{"location":"api/text/#autoresize","title":"autoresize","text":"<p><pre><code>    def autoresize(self, enabled: bool) -&gt; Self:\n</code></pre> Enable or disable automatic text box resizing.</p>"},{"location":"api/text/#arguments_2","title":"Arguments","text":"Name Type Description <code>enabled</code> <code>bool</code> Whether to enable automatic resizing."},{"location":"api/text/#returns_2","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the Text class.</p>"},{"location":"api/text/#baseline","title":"baseline","text":"<p><pre><code>    def baseline(self, baseline: str) -&gt; Self:\n</code></pre> Set the vertical text alignment (top, middle, bottom).</p>"},{"location":"api/text/#arguments_3","title":"Arguments","text":"Name Type Description <code>baseline</code> <code>str</code> The vertical alignment to set."},{"location":"api/text/#returns_3","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the Text class.</p>"},{"location":"api/text/#raises_1","title":"Raises","text":"<p>ValueError: If an invalid vertical alignment is provided.</p>"},{"location":"api/text/#center","title":"center","text":"<p><pre><code>    def center(self, *args) -&gt; Self | tuple[float, float]:\n</code></pre> Get or set the center coordinates of the element.</p>"},{"location":"api/text/#arguments_4","title":"Arguments","text":"Name Type Description <code>*args</code> <code>None</code> Supports two signatures: 1. center() -&gt; tuple[float, float] Returns the (x, y) coordinates of the center. 2. center(x, y) -&gt; Self Sets the center to (x, y) and returns self for chaining."},{"location":"api/text/#returns_4","title":"Returns","text":"<p>Type: <code>tuple[float, float]  or  Self</code></p> <p>Depending on the arguments.</p>"},{"location":"api/text/#color","title":"color","text":"<p><pre><code>    def color(self, color: str | Color) -&gt; Self:\n</code></pre> Set the text color as #RRGGBB, color name or Color object.</p>"},{"location":"api/text/#arguments_5","title":"Arguments","text":"Name Type Description <code>color</code> <code>str  or  Color</code> The color to set."},{"location":"api/text/#returns_5","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the Text class.</p>"},{"location":"api/text/#content","title":"content","text":"<p><pre><code>    def content(self, text: str) -&gt; Self:\n</code></pre> Set the text content and automatically calculate width and height.</p>"},{"location":"api/text/#arguments_6","title":"Arguments","text":"Name Type Description <code>text</code> <code>str</code> The text content to set."},{"location":"api/text/#returns_6","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the Text class.</p>"},{"location":"api/text/#font","title":"font","text":"<p><pre><code>    def font(self, family: str) -&gt; Self:\n</code></pre> Set the font family ('Excalifont', 'Comic Shaans', 'Lilita One', 'Nunito', 'Hand-drawn', 'Normal', 'Code').</p>"},{"location":"api/text/#arguments_7","title":"Arguments","text":"Name Type Description <code>family</code> <code>str</code> The font family to set."},{"location":"api/text/#returns_7","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the Text class.</p>"},{"location":"api/text/#raises_2","title":"Raises","text":"<p>ValueError: If an invalid font family is provided.</p>"},{"location":"api/text/#fontsize","title":"fontsize","text":"<p><pre><code>    def fontsize(self, size: int | str) -&gt; Self:\n</code></pre> Set the font size by int or by string ('S', 'M', 'L', 'XL').</p>"},{"location":"api/text/#arguments_8","title":"Arguments","text":"Name Type Description <code>size</code> <code>int  or  str</code> The font size to set."},{"location":"api/text/#returns_8","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the Text class.</p>"},{"location":"api/text/#raises_3","title":"Raises","text":"<p>ValueError: If an invalid size string is provided.</p> <p>TypeError: If the size is not an int or a valid string.</p>"},{"location":"api/text/#justify","title":"justify","text":"<p><pre><code>    def justify(self, x: float, y: float, width: float, height: float) -&gt; Self:\n</code></pre> Justify the text element within a rectangle defined by (x, y, width, height).</p>"},{"location":"api/text/#arguments_9","title":"Arguments","text":"Name Type Description <code>x</code> <code>float</code> The x-coordinate of the rectangle's top-left corner. <code>y</code> <code>float</code> The y-coordinate of the rectangle's top-left corner. <code>width</code> <code>float</code> The width of the rectangle. <code>height</code> <code>float</code> The height of the rectangle."},{"location":"api/text/#returns_9","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the Text class.</p>"},{"location":"api/text/#link","title":"link","text":"<p><pre><code>    def link(self, target: \"str | AbstractElement\") -&gt; Self:\n</code></pre> Establishes a link to the given target, which can be either a string URL or an AbstractElement instance.</p>"},{"location":"api/text/#arguments_10","title":"Arguments","text":"Name Type Description <code>target</code> <code>str  or  AbstractElement</code> The target to link to. If it's an AbstractElement, a URL will be generated using its ID. If it's a string, it will be used directly as the link."},{"location":"api/text/#returns_10","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the current object with the updated link.</p>"},{"location":"api/text/#raises_4","title":"Raises","text":"<p>ValueError: If the target is neither a string nor an AbstractElement.</p>"},{"location":"api/text/#opacity","title":"opacity","text":"<p><pre><code>    def opacity(self, opacity: int) -&gt; Self:\n</code></pre> Set the opacity of the element.</p>"},{"location":"api/text/#arguments_11","title":"Arguments","text":"Name Type Description <code>opacity</code> <code>int</code> The opacity value to set, must be in the range 0-100. 100 is fully opaque, 0 is fully transparent."},{"location":"api/text/#returns_11","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the element with updated opacity.</p>"},{"location":"api/text/#raises_5","title":"Raises","text":"<p>ValueError: If the opacity value is not within the range 0-100.</p>"},{"location":"api/text/#orbit","title":"orbit","text":"<p><pre><code>    def orbit(self, *args) -&gt; Self:\n</code></pre> Positions the element relative to a reference using polar coordinates. This method allows placing the element such that its center will be at (radius, angle) from a reference. The reference can be either another AbstractElement or a point (x, y).</p>"},{"location":"api/text/#arguments_12","title":"Arguments","text":"Name Type Description <code>*args</code> <code>None</code> Supports two signatures: 1. orbit(element, radius, angle) <code>element</code> <code>AbstractElement</code> The reference element to orbit around. <code>radius</code> <code>float</code> The distance from the center of the reference. <code>angle</code> <code>float</code> The angle to position the element at, in radians."},{"location":"api/text/#returns_12","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the element.</p>"},{"location":"api/text/#raises_6","title":"Raises","text":"<p>ValueError: If the arguments do not match the expected signatures.</p>"},{"location":"api/text/#position","title":"position","text":"<p><pre><code>    def position(self, x: float, y: float) -&gt; Self:\n</code></pre> Sets the position of the element.</p>"},{"location":"api/text/#arguments_13","title":"Arguments","text":"Name Type Description <code>x</code> <code>float</code> The x-coordinate of the element. <code>y</code> <code>float</code> The y-coordinate of the element."},{"location":"api/text/#returns_13","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the element with updated position.</p>"},{"location":"api/text/#rotate","title":"rotate","text":"<p><pre><code>    def rotate(self, angle: float) -&gt; Self:\n</code></pre> Rotate the element clockwise by a specified angle.</p>"},{"location":"api/text/#arguments_14","title":"Arguments","text":"Name Type Description <code>angle</code> <code>float</code> The angle to rotate the element clockwise by, in radians."},{"location":"api/text/#returns_14","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The instance of the element after rotation.</p>"},{"location":"api/text/#size","title":"size","text":"<p><pre><code>    def size(self, *args) -&gt; Self | tuple[float, float]:\n</code></pre> Get or set the size of the element.</p>"},{"location":"api/text/#arguments_15","title":"Arguments","text":"Name Type Description <code>*args</code> <code>None</code> Supports two signatures: 1. size() -&gt; tuple[float, float] Returns the (width, height) of the element. 2. size(width, height) -&gt; Self Sets the size to (width, height) and returns self for chaining."},{"location":"api/text/#returns_15","title":"Returns","text":"<p>Type: <code>tuple[float, float]  or  Self</code></p> <p>Depending on the arguments.</p>"},{"location":"api/text/#spacing","title":"spacing","text":"<p><pre><code>    def spacing(self, height: float) -&gt; Self:\n</code></pre> Set the line height manually.</p>"},{"location":"api/text/#arguments_16","title":"Arguments","text":"Name Type Description <code>height</code> <code>float</code> The line height to set."},{"location":"api/text/#returns_16","title":"Returns","text":"<p>Type: <code>Self</code></p> <p>The current instance of the Text class.</p>"},{"location":"guide/","title":"Developer Guide","text":""},{"location":"guide/#excaligen-developer-guide","title":"Excaligen Developer Guide","text":""},{"location":"guide/#excalidraw-file-generation-via-python","title":"Excalidraw File Generation via Python \u2728","text":"<p>Excaligen bridges the gap between the fantastic diagram editor Excalidraw and algorithmic visualization. Excalidraw is well known for its beautiful, hand-drawn aesthetic. </p> <p>If you want to generate Excalidraw-compatible files directly from Python, Excaligen is the tool for you. Visualize data structures, automated reports, and complex algorithmic patterns with minimal boilerplate.</p>"},{"location":"guide/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Concepts &amp; The First Sketch</li> <li>Shapes &amp; Styles</li> <li>Connectors (Arrows)</li> <li>Typography (Text)</li> <li>Lines &amp; Custom Shapes</li> <li>Images</li> <li>Groups &amp; Frames</li> <li>Defaults</li> <li>Algorithmic Generation</li> </ul>"},{"location":"guide/#concepts-the-first-sketch","title":"Concepts &amp; The First Sketch","text":""},{"location":"guide/#the-scenebuilder","title":"The SceneBuilder","text":"<p>The heart of Excaligen is the <code>SceneBuilder</code> class. Think of it as your canvas and your toolbox combined.</p> <p>Important: You should always create elements using the <code>SceneBuilder</code> methods (like <code>.rectangle()</code>, <code>.arrow()</code>, etc.). Do not instantiate element classes directly. The builder ensures everything is correctly initialized and tied to the diagram.</p>"},{"location":"guide/#hello-world","title":"Hello World","text":"<p>Create a file named <code>hello_world.py</code>:</p> <pre><code>from excaligen.SceneBuilder import SceneBuilder\n\nscene = SceneBuilder()\nscene.text('Hello, World!')\nscene.save('hello_world.excalidraw')\n</code></pre> <p>Executing this script produces a file ready for Excalidraw.</p> <p></p>"},{"location":"guide/#the-fluent-api","title":"The Fluent API","text":"<p>Excaligen uses a \"fluent\" API style. This means you can chain method calls together to configure your elements concisely.</p> <pre><code>from excaligen.SceneBuilder import SceneBuilder\n\nscene = SceneBuilder()\ncentral_topic = scene.ellipse('Central topic').center(0, 0)\nsubtopic = scene.rectangle('Subtopic').center(350, 100)\nscene.arrow('points to').bind(central_topic, subtopic)\n\nscene.save('binding.excalidraw')\n</code></pre> <p></p> <p>The next chapters will explain the API in detail. We will omit the imports and <code>scene.save()</code> calls in examples for brevity.</p>"},{"location":"guide/#shapes-styles","title":"Shapes &amp; Styles","text":"<p>Excalidraw is beloved for its hand-drawn feel. Excaligen gives you full programmatic control over this unique aesthetic.</p>"},{"location":"guide/#core-shapes","title":"Core Shapes","text":"<p>Excaligen exposes the core Excalidraw shapes:</p> <ul> <li>Rectangle: <code>scene.rectangle()</code></li> <li>Ellipse: <code>scene.ellipse()</code></li> <li>Diamond: <code>scene.diamond()</code></li> </ul> <pre><code>scene.rectangle('Rectangle').center(-150, 0)\nscene.ellipse('Ellipse').center(0, 0)\nscene.diamond('Diamond').center(150, 0)\n</code></pre> <p></p>"},{"location":"guide/#positioning","title":"Positioning","text":"<p>You can position elements using three methods:</p> <ul> <li><code>center(x, y)</code></li> <li><code>position(x, y)</code></li> <li><code>orbit(center, radius, angle)</code></li> </ul>"},{"location":"guide/#center","title":"Center","text":"<p><code>center(x, y)</code> places the geometric center of the element at (x, y). <pre><code>scene.ellipse().center(0, 0)\nscene.rectangle().center(0, -120)\nscene.diamond().center(150, 0)\n</code></pre></p> <p></p>"},{"location":"guide/#position","title":"Position","text":"<p><code>position(x, y)</code> places the top-left corner of the element's bounding box at (x, y). <pre><code>scene.rectangle('Rectangle 1').position(0, 0)\nscene.rectangle('Rectangle 2').position(150, 0)\nscene.rectangle('Rectangle 3').position(0, 120)\n</code></pre> </p>"},{"location":"guide/#orbit-polar-coordinates","title":"Orbit / Polar Coordinates","text":"<p>What if we want to place several elements around a central point? The <code>orbit(center, radius, angle)</code> method allows you to do that. <pre><code>RADIUS = 150\nSUBTOPICS = 6\n\nscene = SceneBuilder()\ncentral_topic = scene.ellipse('Central topic').center(0, 0)\nfor i in range(SUBTOPICS):\n    angle = i * 2 * math.pi / SUBTOPICS\n    scene.rectangle(f'Subtopic {i}').orbit(central_topic, RADIUS, angle)\n\nscene.save('sandbox.excalidraw')\n</code></pre></p> <p></p> <p>There is another variant of the orbit method - <code>orbit(x, y, radius, angle)</code> that allows you to specify the coordinates of the center instead of an element.</p>"},{"location":"guide/#rotation","title":"Rotation","text":"<p>You can rotate any element. Angles are in radians.</p> <pre><code>scene.rectangle('Rotated by 45\u00b0').center(0, 0).rotate(math.radians(45))\n</code></pre> <p></p>"},{"location":"guide/#shape-size","title":"Shape Size","text":"<p>You can define the dimensions of a shape using the <code>size()</code> method. It accepts width and height.</p> <p><pre><code>scene.rectangle('Small').size(80, 64).center(0, 0)    \nscene.rectangle('Medium').size(100, 80).center(100, 0)\nscene.rectangle('Large').size(150, 120).center(235, 0)\n</code></pre> </p>"},{"location":"guide/#styling","title":"Styling","text":"<p>A diagram communicates through more than just shapes. The style tells a story.</p>"},{"location":"guide/#stroke-style","title":"Stroke Style","text":"<p>Control the line style with <code>.stroke()</code>. Options:</p> <ul> <li><code>'solid'</code></li> <li><code>'dashed'</code></li> <li><code>'dotted'</code></li> </ul> <p><pre><code>scene.ellipse().center(-150, 0).stroke('solid')\nscene.ellipse().center(0, 0).stroke('dashed')\nscene.ellipse().center(150, 0).stroke('dotted')\n</code></pre> </p>"},{"location":"guide/#stroke-thickness","title":"Stroke Thickness","text":"<p>Adjust the line width with <code>.thickness()</code>. Options: </p> <ul> <li><code>'thin'</code> (1)</li> <li><code>'bold'</code> (2)</li> <li><code>'extra-bold'</code> (3)</li> </ul> <p><pre><code>scene.rectangle().thickness('thin')\nscene.rectangle().thickness('bold')\nscene.rectangle().thickness('extra-bold')\n</code></pre> </p>"},{"location":"guide/#fill-style","title":"Fill Style","text":"<p>Choose how shapes are filled with <code>.fill()</code>. Options:</p> <ul> <li><code>'solid'</code></li> <li><code>'hachure'</code> (sketchy lines)</li> <li><code>'cross-hatch'</code></li> </ul> <p><pre><code>scene.ellipse().center(-150, 0).background('gray').fill('solid')\nscene.ellipse().center(0, 0).background('gray').fill('hachure')\nscene.ellipse().center(150, 0).background('gray').fill('cross-hatch')\n</code></pre> </p>"},{"location":"guide/#roundness","title":"Roundness","text":"<p>Shapes can have sharp or rounded corners. Use the <code>roundness()</code> method to toggle between them. Note that this method is not applicable to the <code>Ellipse</code> element. <pre><code>scene.rectangle('Rounded').roundness('round').center(0, 0)\nscene.rectangle('Sharp').roundness('sharp').center(150, 0)\nscene.diamond('Rounded').roundness('round').center(0, 100)\nscene.diamond('Sharp').roundness('sharp').center(150, 100)\n</code></pre> </p>"},{"location":"guide/#sloppiness","title":"Sloppiness","text":"<p>Control the hand-drawn effect with <code>.sloppiness()</code>. Options:</p> <ul> <li><code>'architect'</code> (clean)</li> <li><code>'artist'</code> (balanced)</li> <li><code>'cartoonist'</code> (messy)</li> </ul> <p><pre><code>scene.rectangle().sloppiness('architect')\nscene.rectangle().sloppiness('artist')\nscene.rectangle().sloppiness('cartoonist')\n</code></pre> </p>"},{"location":"guide/#opacity","title":"Opacity","text":"<p>Control opacity/transparency with <code>.opacity(0-100)</code>. <pre><code>scene.ellipse().center(70, 0).background('gray').fill('cross-hatch')\nscene.ellipse().center(0, 0).background('DarkGray').fill('solid').opacity(80)\n</code></pre> </p>"},{"location":"guide/#colors","title":"Colors","text":"<p>So far we have only used the black/gray colors. But we can use any color we want. Excaligen supports multiple color formats:</p> <ul> <li>Named Colors: <code>\"MidnightBlue\"</code>, <code>\"Tomato\"</code>, <code>\"MintCream\"</code>.</li> <li>RGB as a string (Hex Colors): <code>\"#FF5733\"</code>.</li> <li>RGB: <code>scene.color().rgb(100, 149, 237)</code>.</li> <li>HSL: <code>scene.color().hsl(200, 80, 60)</code>.</li> </ul> <pre><code># Add a rectangle with a named color\n(\n    scene.rectangle('Action')\n    .position(0, 0)\n    .color(\"BlueViolet\")\n    .background(\"Lavender\")\n)\n\n# Add an ellipse with RGB color as a string\n(\n    scene.ellipse('Start')\n    .position(150, 0)\n    .color('#FF5733')\n    .background('#FFBD33')\n)\n\n# Add a diamond with HSL color\n(\n    scene.diamond('Decision')\n    .position(300, 0)\n    .color(scene.color().hsl(120, 100, 25))\n    .background(scene.color().hsl(120, 100, 85))\n)\n</code></pre> <p></p>"},{"location":"guide/#advanced-color-manipulation","title":"Advanced Color Manipulation","text":"<p>Look again at the previous example. A shape's <code>color()</code> method accepts either a string or a <code>Color</code> object.</p> <p>Passing a string as e.g. 'Lavender' or '#FF5733' is the easiest way to set a color.</p> <p>However, if you need more control, you can pass a Color object, that you can create using the <code>scene.color()</code> helper. This is useful for generating colors programatically. The color object exposes the <code>rgb()</code> and <code>hsl()</code> methods to create colors.</p> <pre><code>color_1 = scene.color().rgb(250, 120, 10)\ncolor_2 = scene.color().hsl(200, 80, 60)\n\nscene.rectangle('Color 1').color(color_1).background(color_1).center(0, 0)\nscene.rectangle('Color 2').color(color_2).background(color_2).center(150, 0)\n</code></pre> <p></p> <p>There are also methods <code>lighten()</code> and <code>darken()</code> to manipulate lightness of the colors, taking a percentage as an argument.</p> <pre><code>for i in range(5, 30, 5):\n    color = scene.color().rgb(250, 120, 10).darken(i)\n    (\n        scene.ellipse()\n        .center(i * 20, 0)\n        .size(80, 80)\n        .color(color)\n        .background(color)\n        .fill('solid')\n    )\n</code></pre> <p></p> <p>Using the HSL color space you can also manipulate the saturation and hue of the colors.</p> <p><pre><code>for i in range(0, 90, 10):\n    color = scene.color().hsl(200, 80 - i, 60)\n    (\n        scene.ellipse()\n        .center(i * 10, 0)\n        .size(80, 80)\n        .color(color)\n        .background(color)\n        .fill('solid')\n    )\n\n    color = scene.color().hsl(200 + i, 80, 60)\n    (\n        scene.ellipse()\n        .center(i * 10, 100)\n        .size(80, 80)\n        .color(color)\n        .background(color)\n        .fill('solid')\n    )\n</code></pre> </p>"},{"location":"guide/#connectors-arrows","title":"Connectors (Arrows)","text":"<p>Diagrams are about relationships. <code>Arrow</code> is a powerful element to express them.</p>"},{"location":"guide/#binding","title":"Binding","text":"<p>The most robust way to connect elements is binding them by an arrow. When elements move, bound arrows follow.</p> <p><pre><code>source = scene.rectangle('Source').center(0, 0)\ntarget = scene.rectangle('Target').center(120, 0)\nscene.arrow().bind(source, target)\n</code></pre> </p>"},{"location":"guide/#labels","title":"Labels","text":"<p>Arrows can have labels.</p> <pre><code>source = scene.rectangle('Source').center(0, 0)\ntarget = scene.rectangle('Target').center(320, 0)\nscene.arrow('My Label').bind(source, target)\n</code></pre> <p></p>"},{"location":"guide/#styling_1","title":"Styling","text":"<p>You can adjust color, stroke style, thickness, and sloppiness in the same way as for shapes.</p> <pre><code>source = scene.rectangle('Source').center(0, 0)\ntarget = scene.rectangle('Target').center(220, 0)\nscene.arrow().bind(source, target).color('red').stroke('dashed').thickness('extra-bold')\n</code></pre> <p></p>"},{"location":"guide/#arrowheads","title":"Arrowheads","text":"<p>Customize the start and end markers. Options are:</p> <ul> <li><code>'arrow'</code></li> <li><code>'bar'</code></li> <li><code>'dot'</code></li> <li><code>'triangle'</code></li> <li><code>None</code></li> </ul> <pre><code>y = 0\nfor arrow_head in [None, 'arrow', 'bar', 'dot', 'triangle']:\n    start_element = scene.ellipse().center(0, y).size(30, 30).color('gray')\n    end_element = scene.rectangle(f\"{arrow_head}\").center(120, y).size(100, 30).color('gray')\n    scene.arrow().bind(start_element, end_element).arrowheads(None, arrow_head).color('blue')\n    y += 50\n</code></pre> <p></p> <p>You can of course use any combination of arrowheads, e.g. starting with a dot and ending with a triangle.</p>"},{"location":"guide/#path-styles","title":"Path Styles","text":"<p>It's about how the arrow gets from A to B. Excalidraw supports direct, elbowed and freeform paths. Excaligen adds convenience methods to control the curved and arc paths.  In summary, you can control the arrow path to achieve:</p> <ul> <li>Straight connection</li> <li>Elbow (orthogonal) connection</li> <li>Curved connection</li> <li>Arc connection</li> <li>Freeform connection</li> </ul>"},{"location":"guide/#straight-connectiondefault","title":"Straight Connection(Default)","text":"<p>A direct line between shapes, you saw it in the previous examples.</p> <pre><code>scene.arrow().bind(node_a, node_b)\n</code></pre>"},{"location":"guide/#elbow-orthogonal-connection","title":"Elbow (Orthogonal) Connection","text":"<p>Elbow arrows provide a structured way to connect elements using only horizontal and vertical segments. This is ideal for complex diagrams like flowcharts or system architectures, as it helps avoid diagonal lines that can make a layout look cluttered or confusing.</p> <p>You specify the exit direction from <code>start</code> and entry direction to <code>end</code> (<code>'U'</code>, <code>'D'</code>, <code>'L'</code>, <code>'R'</code>) meaning up, down, left, right.</p> <pre><code>begin = scene.rectangle('Begin').center(0, 0).size(160, 70)\nend = scene.ellipse('End').center(400, -200).size(130, 50)\nscene.arrow().elbow('R', 'L').bind(begin, end)\nscene.arrow().elbow('U', 'U').bind(begin, end)\nscene.arrow().elbow('D', 'D').bind(begin, end)\nscene.arrow().elbow('L', 'R').bind(begin, end)\n</code></pre> <p></p>"},{"location":"guide/#curve-connection","title":"Curve Connection","text":"<p>If you prefer more organic, flowing lines, use curve arrows. You define the \"tangent\" angle at the start and end. Angles can be radians or convenience directions (<code>'U'</code>, <code>'D'</code>, <code>'L'</code>, <code>'R'</code>).</p> <pre><code>center = scene.ellipse('Center').center(0, 0)\ntop_left = scene.rectangle('Top Left').center(-300, -100)\ntop_right = scene.rectangle('Top Right').center(300, -100)\nbottom_left = scene.rectangle('Bottom Left').center(-300, 100)\nbottom_right = scene.rectangle('Bottom Right').center(300, 100)\n\nscene.arrow().curve('L', 'R').bind(center, top_left)\nscene.arrow().curve('L', 'R').bind(center, bottom_left)\nscene.arrow().curve('R', 'L').bind(center, top_right)\nscene.arrow().curve('R', 'L').bind(center, bottom_right)\n</code></pre> <p></p> <p>As mentioned above, you can use angles instead of directions. Just please be aware that the underlying approximation algorithm tries to use as few control points as possible, so the resulting curve might not be exactly what you expect.</p> <pre><code>center = scene.ellipse('Main').center(-250, 0)\nbottom_left = scene.rectangle('Bottom Left').center(-160, 200)\nbottom_right = scene.rectangle('Bottom Right').center(160, 200)\nbottom_center = scene.rectangle('Bottom Center').center(0, 200)\n\nscene.arrow().curve(math.radians(15), 'U').bind(center, bottom_right)\nscene.arrow().curve(math.radians(30), 'U').bind(center, bottom_center)\nscene.arrow().curve(math.radians(45), 'U').bind(center, bottom_left)\n</code></pre> <p></p>"},{"location":"guide/#arc-connection","title":"Arc Connection","text":"<p>Arc arrows create a circular path between two points, maintaining a constant radius. This is ideal for circular layouts, cycles, or when you need a consistent, rounded connection that follows a specific curvature.</p> <pre><code>RADIUS = 300\nelements = []\n\nfor angle in range(0, 360, 30):\n    rect = scene.ellipse(f'{angle}\u00b0').orbit(0, 0, RADIUS, math.radians(angle)).size(80, 60)\n    elements.append(rect)\n\nstart_element = elements[0]\nfor i in range(1, len(elements)):\n    scene.arrow().arc(RADIUS).bind(start_element, elements[i])\n    start_element = elements[i]\n</code></pre> <p></p>"},{"location":"guide/#freeform-connection","title":"Freeform Connection","text":"<p>Freeform arrows provide a flexible way to connect elements using a series of points. This is ideal for complex diagrams where you need to create a custom path between two points. The line segments can connect to each other in a sharp or rounded way.</p> <pre><code>START = 50\nEND = 500\n\nstart = scene.ellipse('start').center(0, 0).size(100, 100)\nend = scene.ellipse('end').center(530, 0).size(60, 60)\npoints = [(START, 0), (300, -30), (250, 30), (END, 0)]\nscene.arrow().points(points).bind(start, end).roundness('sharp')\n</code></pre> <p></p> <p>For example, you can generate the points using harmonic functions:</p> <pre><code>START = 50\nEND = 500\nNUM_POINTS = 30\nNUM_CYCLES = 5\npoints = [(\n    x := START + (t := i / (NUM_POINTS - 1)) * (END - START), \n    (envelope := 50 * math.sin(math.pi * t)) * math.sin(2 * math.pi * NUM_CYCLES * t)) \n    for i in range(NUM_POINTS)]\n\nstart = scene.ellipse('start').center(0, 0).size(100, 100)\nend = scene.ellipse('end').center(530, 0).size(60, 60)\n\nscene.arrow().points(points).bind(start, end)\n</code></pre> <p></p>"},{"location":"guide/#typography-text","title":"Typography (Text)","text":"<p>You have already seen some text labels in the previous examples. Those labels used the default font and default styling. E.g. the code <code>rectangle('Hello')</code> creates a rectangle with the text 'Hello' in it, rendered in the default font and styling.</p> <p>If you want to create a text label using non-default font and styling, you need to create a text element using the <code>text()</code> instead of using a plain text string.</p>"},{"location":"guide/#fonts","title":"Fonts","text":"<p>The following fonts are available in Excalidraw:</p> <ul> <li>Excalifont</li> <li>Comic Shaans</li> <li>Lilita One</li> <li>Nunito</li> <li>Hand-drawn</li> <li>Normal</li> <li>Code</li> </ul> <pre><code>for i, font in enumerate(['Excalifont', 'Comic Shaans', 'Lilita One', 'Nunito', 'Hand-drawn', 'Normal', 'Code']):\n    scene.text(f\"{font}\").center(0, i * 20).font(font)\n</code></pre> <p></p>"},{"location":"guide/#font-size","title":"Font Size","text":"<p>You can set the font size using the <code>.fontsize()</code> method. The available sizes are 'S', 'M', 'L', and 'XL'. You can also get the size of a text element using the <code>size()</code> method without any arguments.</p> <pre><code>y = 0\nfor size in ['S', 'M', 'L', 'XL']:\n    text = scene.text(f\"Excalifont ({size})\").font('Excalifont').center(0, y).fontsize(size)\n    w, h = text.size()\n    y += h\n</code></pre> <p></p>"},{"location":"guide/#color","title":"Color","text":"<p>Let's create a non-default text label for an element apply some color to it.</p> <pre><code>colored_text = (scene.text(\"Hello, World!\")\n    .font('Lilita One')\n    .fontsize('L')\n    .color('Violet')\n)\nscene.rectangle(colored_text).size(200, 100).center(0, 0)\n</code></pre> <p></p>"},{"location":"guide/#layout-helpers","title":"Layout Helpers","text":""},{"location":"guide/#justification","title":"Justification","text":"<pre><code>y = 0\nfor baseline in ['top', 'middle', 'bottom']:\n    x = -300\n    for align in ['left', 'center', 'right']:\n        scene.rectangle(scene.text(f'{align}-{baseline}').align(align).baseline(baseline)).size(200, 120).center(x, y)\n        x += 300\n    y += 150\n</code></pre>"},{"location":"guide/#anchoring","title":"Anchoring","text":"<pre><code>def cross(center: tuple[float, float], color: str) -&gt; None:\n    x, y = center\n    scene.line().points([[x - 20, y], [x + 20, y]]).color(color)\n    scene.line().points([[x, y - 20], [x, y + 20]]).color(color)\n\nscene = SceneBuilder()\nx = 42.0\ny = 0.0\n\nfor h_align in [\"left\", \"center\", \"right\"]:\n    for v_align in [\"top\", \"middle\", \"bottom\"]:\n        cross((x, y), 'red')\n        scene.text().anchor(x, y, h_align, v_align).content(f\"{h_align}-{v_align}\").fontsize(\"M\").font(\"Hand-drawn\").color(\"black\")\n        y += 60.0\n</code></pre> <p>Text needs to be placed precisely.</p> <ul> <li><code>justify(x, y, w, h)</code> Aligns text within a box.</li> <li><code>anchor(x, y, h_align, v_align)</code> Anchors text to a point (e.g., top-left).</li> </ul>"},{"location":"guide/#lines-custom-shapes","title":"Lines &amp; Custom Shapes","text":"<p>The Line object accepts a list of points. It uses 'round' interpolation between points by default.</p> <p><pre><code>scene.line().points([(-100, 0), (0, 30), (50, -50), (100, 0)]).thickness('extra-bold')\n</code></pre> </p>"},{"location":"guide/#custom-polygons","title":"Custom Polygons","text":"<p>The Line object has a convenience method <code>.close()</code> to connect the last point to the first. This creates a shape that can be filled.</p> <p><pre><code>points = [[-100, 0], [100, 0], [0, -100]]\n(\n    scene.line()\n    .points(points)\n    .close()\n    .background('lightgreen')\n    .fill('cross-hatch')\n    .color('darkgreen')\n    .roundness('sharp')\n    .thickness('bold')\n)\n</code></pre> </p> <p>Example of a more complex polygon:</p> <pre><code>OUTER_R = 80\nINNER_R = 35\nNUM_POINTS = 10\n\nstar_points = [(\n    (r := (OUTER_R if i % 2 == 0 else INNER_R)) * math.cos(theta := i * (2 * math.pi / NUM_POINTS)),\n    r * math.sin(theta)\n) for i in range(NUM_POINTS)]\n\nscene.line().points(star_points).close().roundness('sharp')\n</code></pre> <p></p>"},{"location":"guide/#images","title":"Images","text":"<p>Sometimes you need to include images in your scenes. You can do this using Image objects. Excaligen supports loading images from files, URLs, or even directly from data.</p>"},{"location":"guide/#loading-images-from-files","title":"Loading Images from Files","text":"<p>The following example shows how to load an image from a file and combine it with text. <pre><code>scene.image().file(\"assets/robot.svg\").center(0, 0)\nscene.text(\"Oh look, I'm expressing joy\").center(0, -150)\nscene.text(\"how utterly revolting\").center(0, 130)\n</code></pre></p> <p></p>"},{"location":"guide/#loading-images-from-data","title":"Loading Images from Data","text":"<p>You can provide the image data directly. The following example shows how to load an SVG image from a string <pre><code>    IMAGE_DATA = '''\n        &lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"467\" height=\"462\" stroke=\"#000\" stroke-width=\"2\"&gt;\n            &lt;rect x=\"80\" y=\"60\" width=\"250\" height=\"250\" rx=\"20\" fill=\"#F80\"/&gt;\n            &lt;circle cx=\"310\" cy=\"290\" r=\"120\" fill=\"#00F\" fill-opacity=\".7\"/&gt;\n        &lt;/svg&gt;'''\n\n    scene.image().data(IMAGE_DATA)\n</code></pre></p> <p></p> <p>You can load images from binary data as well, but that is outside the scope of this guide.</p>"},{"location":"guide/#loading-images-from-urls","title":"Loading Images from URLs","text":"<pre><code>scene.image().url(\"https://picsum.photos/512/320\")\n</code></pre>"},{"location":"guide/#fitting-images","title":"Fitting Images","text":"<p>You can fit images to a specific size using the <code>.fit(w, h)</code> method. This way you don't need to take care of the image size and its aspect ratio, while putting the image in a certain box. <pre><code>scene.rectangle().size(200, 160).center(0, 0)\nscene.image().file('assets/robot.svg').fit(140, 140).center(0, 0)\n</code></pre></p> <p></p>"},{"location":"guide/#groups-frames","title":"Groups &amp; Frames","text":"<p>Organizing elements is key for complex diagrams. Excaligen supports Excalidraw's Groups and Frames.</p>"},{"location":"guide/#groups","title":"Groups","text":"<p>A Group is a virtual container. Elements in a group are treated as a single unit when moving or selecting them in Excalidraw.</p> <pre><code>face = scene.ellipse().center(0, 0).size(120, 120).background('Yellow').fill('solid')\neye_l = scene.ellipse().center(-20, -15).size(15, 25).background('Black').fill('solid')\neye_r = scene.ellipse().center(20, -15).size(15, 25).background('Black').fill('solid')\nmouth = scene.line().points([(-40, 10), (-15, 35), (15, 35), (40, 10)]).thickness('bold')\n\nscene.group().elements(face, eye_l, eye_r, mouth)\n</code></pre> <p></p>"},{"location":"guide/#frames","title":"Frames","text":"<p>A Frame is a visual container that physically surrounds its content. It has a background color and a title. It's perfect for distinct sections of a diagram or creating presentation slides.</p> <p>The following example also demonstrates how to generate links. Excalidraw supports external links and links to other elements in the same scene. As the frame is also an element, it can be linked to.</p> <p><pre><code>first_frame = scene.frame(\"Frame 1\")\nsecond_frame = scene.frame(\"Frame 2\")\n\nheadline_first = (\n    scene.text(\"First Slide\")\n    .center(0, -150)\n)\n\ncircle_with_link = (\n    scene.ellipse()\n    .size(50, 50)\n    .background(\"Green\")\n    .fill(\"solid\")\n    .center(0, -100)\n    .link(\"https://www.google.com\")\n)\n\nbutton_next = (\n    scene.rectangle(\"Next\")\n    .size(100, 50)\n    .background(\"LightBlue\")\n    .fill(\"solid\")\n    .center(0, 0)\n    .link(second_frame)\n)\n\nheadline_second = (\n    scene.text(\"Second Slide\")\n    .center(0, 300)\n)\n\nbutton_back = (\n    scene.rectangle(\"Back\")\n    .size(100, 50)\n    .background(\"LightBlue\")\n    .fill(\"solid\")\n    .center(0, 400)\n    .link(first_frame)\n)\n\nfirst_frame.elements(headline_first, circle_with_link, button_next)\nsecond_frame.elements(headline_second, button_back)\n</code></pre> </p>"},{"location":"guide/#defaults","title":"Defaults","text":"<p>What if you want to use specific styles for several elements, but you don't want to type e.g. <code>stroke('solid')</code>, <code>fill('solid')</code>, etc. for each element?  Excaligen provides the <code>Defaults</code> object for this purpose. Let's take the same setup we used in the first chapter, but this time, we'll override the defaults and apply our own styling:</p> <p><pre><code>(\n    scene.defaults()\n    .stroke('solid')\n    .thickness('bold')\n    .fill('solid')\n    .roundness('round')\n    .sloppiness('architect')\n    .font('Nunito')\n)\n\ncentral_topic = scene.ellipse('Central topic').center(0, 0)\nsubtopic = scene.rectangle('Subtopic').center(350, 100)\nscene.arrow('points to').bind(central_topic, subtopic)  \n</code></pre> </p>"},{"location":"guide/#algorithmic-generation","title":"Algorithmic Generation","text":"<p>The true power of Excaligen lies in automation. Below are real-world examples of generating complex diagrams programmatically. You can find the source code for these examples in the 'examples' directory.</p>"},{"location":"guide/#mind-map-example","title":"Mind Map Example","text":""},{"location":"guide/#workflow-example","title":"Workflow Example","text":""},{"location":"guide/#pie-chart-example","title":"Pie Chart Example","text":""},{"location":"guide/#curves-and-arrows-example","title":"Curves and Arrows Example","text":""},{"location":"guide/#beyond-diagrams","title":"Beyond Diagrams","text":"<p>You are not limited to creating diagrams. Excalidraw is a tool for creative people and so is Excaligen. Can you guess what the following code generates?</p> <pre><code>D = 42 * (42 * (42 * (42 * (42 * (42 * (42 * (42 * 3) + 25) + 26) + 2) + 28) + 30) + 8)\n\nfor y in range(8):\n    for x in range(11):\n        if (D &gt;&gt; ((y * 6) + abs(5 - x))) &amp; 1:\n            s.rectangle().position(x * 42, y * 42).size(42, 42).color('#ff4242').background(\"#ff4242\").fill(\"solid\").roundness('sharp').sloppiness('architect')\n</code></pre> <p>After running the last example code you know the \"Answer to the Ultimate Question of Life, the Universe, and Everything\" \ud83d\ude00</p> <p>And that's a wrap! \ud83c\udf89 You've made it to the end of the guide. You now have everything you need to start generating beautiful Excalidraw scenes from your Python code.</p> <p>Have fun with Excaligen.</p>"}]}